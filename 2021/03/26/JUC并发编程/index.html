<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.1.1" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.1.1" type="image/png" sizes="32x32"><meta name="description" content="JUC并发编程                     1、什么是 JUC       JUC就是 java.util.concurrent,也就是java工具类，在并发编程中使用。">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC并发编程">
<meta property="og:url" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="源一先生">
<meta property="og:description" content="JUC并发编程                     1、什么是 JUC       JUC就是 java.util.concurrent,也就是java工具类，在并发编程中使用。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/0.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/2.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/3.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/4.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/5.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/6.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/7.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/8.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/9.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/10.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/11.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/12.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/13.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/14.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/15.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/16.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/17.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/18.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/19.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/20.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/21.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/22.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/23.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/24.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/25.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/26.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/27.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/28.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/29.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/30.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/31.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/32.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/33.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/34.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/35.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/36.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/37.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/38.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/39.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/40.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/41.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/42.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/43.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/44.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/45.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/46.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/47.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/48.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/49.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/50.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/51.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/52.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/53.png">
<meta property="og:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/54.png">
<meta property="article:published_time" content="2021-03-26T09:22:09.671Z">
<meta property="article:modified_time" content="2021-03-29T07:18:33.044Z">
<meta property="article:author" content="源一">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/0.png"><title>JUC并发编程 | 源一先生</title><link ref="canonical" href="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.1.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"Copy","copySuccess":"Copy Success","copyError":"Copy Error"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 4.2.1"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">Home</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">Archives</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">Categories</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">Tags</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">源一先生</div><div class="header-banner-info__subtitle"></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">JUC并发编程</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2021-03-26</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2021-03-29</span></span></div></header><div class="post-body"><p>JUC并发编程</p>

        <h2 id="1、什么是-JUC"   >
          <a href="#1、什么是-JUC" class="heading-link"><i class="fas fa-link"></i></a>1、什么是 JUC</h2>
      <p>JUC就是 java.util.concurrent,也就是java工具类，在并发编程中使用。 </p>
<a id="more"></a>
<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/0.png" class="" title="图片">

<blockquote>
<p>普通的线程代码：</p>
</blockquote>
<ul>
<li><strong>Thread</strong></li>
<li><strong>Runnable</strong> 没有返回值、效率相比入 Callable 相对较低！</li>
<li><strong>Callable</strong> 有返回值！（企业常用）</li>
</ul>

        <h2 id="2、线程和进程"   >
          <a href="#2、线程和进程" class="heading-link"><i class="fas fa-link"></i></a>2、线程和进程</h2>
      <ul>
<li><p><strong>进程</strong>：<strong>进程是资源（CPU、内存等）分配的基本单位</strong>，它是程序执行时的一个实例。</p>
<p>程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列</p>
<p>进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。</p>
</li>
<li><p>一个进程往往可以包含多个线程，至少包含一个！</p>
</li>
<li><p><strong>Java默认有2个线程？ mian、GC</strong></p>
</li>
<li><p><strong>线程</strong>：<strong>线程是程序执行时的最小单位</strong>，它是进程的一个执行流，是<strong>CPU调度和分派的基本单位</strong>。</p>
<p>一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。</p>
<p>线程由CPU<strong>独立调度执行</strong>，在多CPU环境下就允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理。</p>
</li>
<li><p>开了一个进程 Typora，写字，自动保存（线程负责的）</p>
</li>
<li><p>对于Java而言提供了：<code>Thread、Runnable、Callable</code>操作线程。</p>
</li>
</ul>

        <h4 id="Java-真的可以开启线程吗？"   >
          <a href="#Java-真的可以开启线程吗？" class="heading-link"><i class="fas fa-link"></i></a>Java 真的可以开启线程吗？</h4>
      <p>答案是：开不了的！</p>
<p>源码：</p>
<p>调用的是本地的方法（native）</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is not invoked for the main method thread </span></span><br><span class="line"><span class="comment">     * or "system" group threads created/set up by the VM. Any new </span></span><br><span class="line"><span class="comment">     * functionality added to this method in the future may have to </span></span><br><span class="line"><span class="comment">     * also be added to the VM.A zero status value corresponds to </span></span><br><span class="line"><span class="comment">     * state "NEW".</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">     * so that it can be added to the group's list of threads</span></span><br><span class="line"><span class="comment">     * and the group's unstarted count can be decremented. </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    group.add(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">              it will be passed up the call stack */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 本地方法，底层操作的是C++ ，Java 无法直接操作硬件</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;<span class="comment">//Native Method就是一个Java调用非Java代码的接口</span></span><br></pre></td></tr></table></div></figure>




        <h4 id="并发、并行"   >
          <a href="#并发、并行" class="heading-link"><i class="fas fa-link"></i></a>并发、并行</h4>
      <p>并发编程：并发、并行（<strong>本质：充分利用CPU的资源</strong>）</p>
<p><strong>并发</strong>（多线程操作同一个资源）</p>
<ul>
<li>一核CPU，模拟出来多条线程，快速交替。</li>
</ul>
<p><strong>并行</strong>（多个人一起行走）</p>
<ul>
<li>多核CPU ，多个线程可以同时执行； 想要最高性能使用 <strong>线程池！</strong>去操作。</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 获取cpu的核数 </span></span><br><span class="line">     <span class="comment">// CPU 密集型，IO密集型 </span></span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line">     <span class="comment">// 如果电脑是8核，则结果输出8</span></span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h5 id="线程有几个状态"   >
          <a href="#线程有几个状态" class="heading-link"><i class="fas fa-link"></i></a>线程有几个状态</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment">     * 线程新生状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NEW,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment">     * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment">     * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment">     * such as processor.</span></span><br><span class="line"><span class="comment">     * 线程运行中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNNABLE,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment">     * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment">     * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment">     * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment">     * 线程阻塞状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BLOCKED,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment">     * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment">     * following methods:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment">     * perform a particular action.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span></span><br><span class="line"><span class="comment">     * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * is waiting for a specified thread to terminate.</span></span><br><span class="line"><span class="comment">     * 线程等待状态，死等</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WAITING,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment">     * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment">     * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     * 线程超时等待状态，超过一定时间就不再等</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment">     * The thread has completed execution.</span></span><br><span class="line"><span class="comment">     * 线程终止状态，代表线程执行完毕</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="wait-sleep-区别"   >
          <a href="#wait-sleep-区别" class="heading-link"><i class="fas fa-link"></i></a>wait/sleep 区别</h4>
      <p><strong>1、二者来自不同的类</strong></p>
<ul>
<li>wait =&gt; Object</li>
<li>sleep =&gt; Thread</li>
</ul>
<p><strong>2、关于锁的释放</strong></p>
<ul>
<li>wait 会释放锁</li>
<li>sleep 不会释放</li>
</ul>
<p><strong>3、使用的范围是不同的</strong></p>
<ul>
<li><strong>wait 必须在同步代码块中使用</strong>（中断异常）</li>
<li>sleep <strong>可以再任何地方睡眠</strong>（需要抛出异常，超时等待）</li>
</ul>

        <h2 id="3、Synchronized锁"   >
          <a href="#3、Synchronized锁" class="heading-link"><i class="fas fa-link"></i></a>3、Synchronized锁</h2>
      <p>传统 Synchronized锁</p>
<p>卖票</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicketTDemo01</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 真正的多线程开发，公司中的开发，降低耦合性</span></span><br><span class="line"><span class="comment">     * 线程就是一个单独的资源类，没有任何附属的操作！</span></span><br><span class="line"><span class="comment">     * 1、 属性、方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//并发：多个线程同时操作一个资源类，把资源类丢入线程</span></span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="comment">// @FunctionalInterface 函数式接口，jdk1.8 lambada表达式</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"C"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//资源类 OOP</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">    <span class="comment">//属性、方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">50</span>;</span><br><span class="line">    <span class="comment">// 卖票的方式</span></span><br><span class="line">    <span class="comment">// synchronized 本质: 队列，锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"卖出了"</span> +</span><br><span class="line">                    (<span class="number">50</span>-(--number)) + <span class="string">"张票，剩余:"</span> + number + <span class="string">"张票"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="4、Lock锁-重点"   >
          <a href="#4、Lock锁-重点" class="heading-link"><i class="fas fa-link"></i></a>4、Lock锁(重点)</h2>
      <p>Lock 接口</p>
<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1.png" class="" title="图片">

<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/2.png" class="" title="图片">

<ul>
<li><strong>公平锁：线程执行顺序按照先来后到顺序</strong></li>
<li><strong>非公平锁：可以插队 （默认锁）</strong></li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicketTDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//并发：多个线程同时操作一个资源类，把资源类丢入线程</span></span><br><span class="line">        Ticket2 ticket = <span class="keyword">new</span> Ticket2();</span><br><span class="line">        <span class="comment">// @FunctionalInterface 函数式接口，jdk1.8 lambada表达式</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"C"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Lock 3步骤</span></span><br><span class="line"><span class="comment">// 1. new ReentrantLock();</span></span><br><span class="line"><span class="comment">// 2. lock.lock()  加锁</span></span><br><span class="line"><span class="comment">// 3. lock.unlock() 解锁</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//属性、方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">50</span>;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// 卖票方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();<span class="comment">// 加锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 业务代码</span></span><br><span class="line">            <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"卖出了"</span> +</span><br><span class="line">                        (<span class="number">50</span> - (--number)) + <span class="string">"张票，剩余:"</span> + number + <span class="string">"张票"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();<span class="comment">// 解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="Synchronized-和-Lock-区别："   >
          <a href="#Synchronized-和-Lock-区别：" class="heading-link"><i class="fas fa-link"></i></a>Synchronized 和 Lock 区别：</h4>
      <ul>
<li>1、Synchronized 内置的Java<strong>关键字</strong>， Lock 是一个<strong>Java类</strong></li>
<li>2、Synchronized <strong>无法判断获取锁的状态</strong>，Lock 可以<strong>判断是否获取到了锁</strong></li>
<li>3、Synchronized <strong>会自动释放锁</strong>，lock 必须要<strong>手动释放</strong>锁！如果不释放锁，<strong>死锁</strong></li>
<li>4、Synchronized 线程 1（获得锁，如果线程1阻塞）、线程2（等待，傻傻的等）；Lock锁就不一定会等待下去(tryLock)；</li>
<li>5、Synchronized <strong>可重入锁，不可以中断的，非公平</strong>；Lock ，<strong>可重入锁，可以判断锁，非公平</strong>（可以自己设置）；(可重入就是说某个线程已经获得某个锁，可以再次获取锁而不会出现死锁)</li>
<li>6、Synchronized 适合锁少量的代码同步问题，Lock 适合锁大量的同步代码！</li>
</ul>

        <h2 id="5、生产者和消费者问题"   >
          <a href="#5、生产者和消费者问题" class="heading-link"><i class="fas fa-link"></i></a>5、生产者和消费者问题</h2>
      <p>面试常考的问题：单例模式、排序算法、生产者和消费者、死锁</p>
<blockquote>
<p>生产者和消费者问题 Synchronized 版</p>
</blockquote>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程之间的通信问题：生产者和消费者问题！  等待唤醒，通知唤醒</span></span><br><span class="line"><span class="comment"> * 线程交替执行  A   B 操作同一个变量   num = 0</span></span><br><span class="line"><span class="comment"> * A num+1</span></span><br><span class="line"><span class="comment"> * B num-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data data = <span class="keyword">new</span> Data();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"C"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"D"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断等待，业务，通知</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 数字 资源类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//+1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        假设 number此时等于1，即已经被生产了产品</span></span><br><span class="line"><span class="comment">        如果这里用的是if判断，如果此时A,C两个生产者线程争夺increment()方法执行权</span></span><br><span class="line"><span class="comment">        假设A拿到执行权，经过判断number!=0成立，则A.wait()开始等待（wait()会释放锁），然后C试图去执行</span></span><br><span class="line"><span class="comment">        生产方法，但依然判断number!=0成立，则B.wait()开始等待（wait()会释放锁）</span></span><br><span class="line"><span class="comment">        碰巧这时候消费者线程线程B/D去消费了一个产品，使number=0然后，B/D消费完后调用this.notifyAll();</span></span><br><span class="line"><span class="comment">        这时候2个等待中的生产者线程继续生产产品，而此时number++ 执行了2次</span></span><br><span class="line"><span class="comment">        同理，重复上述过程，生产者线程继续wait()等待，消费者调用this.notifyAll();</span></span><br><span class="line"><span class="comment">        然后生产者继续超前生产，最终导致‘产能过剩’，即number大于1</span></span><br><span class="line"><span class="comment">        if(number != 0)&#123;</span></span><br><span class="line"><span class="comment">            // 等待</span></span><br><span class="line"><span class="comment">            this.wait();</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="comment">// 注意这里不可以用if 否则会出现虚假唤醒问题，解决方法将if换成while</span></span><br><span class="line">            <span class="comment">// 等待</span></span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"=&gt;"</span> + number);</span><br><span class="line">        <span class="comment">// 通知其他线程，我+1完毕了</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//-1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 等待</span></span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"=&gt;"</span> + number);</span><br><span class="line">        <span class="comment">// 通知其他线程，我-1完毕了</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/3.png" class="" title="图片">

<p>就是用if判断的话，唤醒后线程会从wait之后的代码开始运行，但是不会重新判断if条件，直接继续运行if代码块之后的代码，而如果使用while的话，也会从wait之后的代码运行，但是唤醒后会重新判断循环条件，如果不成立再执行while代码块之后的代码块，成立的话继续wait。</p>
<p>自己理解：</p>
<p>因为if只进行了一次判断，当两个线程同时进入时，第一个判断的值改变了，但是这时候第二个进程并没有更新的值进行判断，而是继续原来的判断，（都在等待，所以都执行）所以会导致值重复增加。</p>
<p>（a，c执行完毕，i=2，此时a再进来，wait了，c进来，wait了，这时候b执行，执行完，i=1，唤醒a，c，i加了两次，就3了）</p>

        <h4 id="JUC版的生产者和消费者问题"   >
          <a href="#JUC版的生产者和消费者问题" class="heading-link"><i class="fas fa-link"></i></a>JUC版的生产者和消费者问题</h4>
      <img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/4.png" class="" title="图片">

<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/5.png" class="" title="图片">

<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/6.png" class="" title="图片">

<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/7.png" class="" title="图片">

<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程之间的通信问题：生产者和消费者问题！  等待唤醒，通知唤醒</span></span><br><span class="line"><span class="comment"> * 线程交替执行  A   B 操作同一个变量   num = 0</span></span><br><span class="line"><span class="comment"> * A num+1</span></span><br><span class="line"><span class="comment"> * B num-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data2 data = <span class="keyword">new</span> Data2();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"C"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"D"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断等待，业务，通知</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data2</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 数字 资源类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition condition = lock.newCondition();</span><br><span class="line">    <span class="comment">//condition.await(); // 等待 </span></span><br><span class="line">    <span class="comment">//condition.signalAll(); // 唤醒全部</span></span><br><span class="line">    <span class="comment">//+1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 业务代码</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 等待</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"=&gt;"</span> + number);</span><br><span class="line">            <span class="comment">// 通知其他线程，我+1完毕了</span></span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//-1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 等待</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"=&gt;"</span> + number);</span><br><span class="line">            <span class="comment">// 通知其他线程，我-1完毕了</span></span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>问题：ABCD线程 抢占执行的顺序是随机的，如果想让ABCD线程有序执行，该如何改进代码？</strong></p>
<p>代码实现：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A 执行完调用B，B执行完调用C，C执行完调用A</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data3 data = <span class="keyword">new</span> Data3();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data.printA();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data.printB();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data.printC();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"C"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data3</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 资源类 Lock</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition3 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>; </span><br><span class="line">    <span class="comment">// number=1 A执行  number=2 B执行 number=3 C执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 业务，判断-&gt; 执行-&gt; 通知</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// A等待</span></span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"=&gt;AAAAAAA"</span>);</span><br><span class="line">            <span class="comment">// 唤醒，唤醒指定的人，B</span></span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 业务，判断-&gt; 执行-&gt; 通知</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// B等待</span></span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"=&gt;BBBBBBBBB"</span>);</span><br><span class="line">            <span class="comment">// 唤醒，唤醒指定的人，c</span></span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 业务，判断-&gt; 执行-&gt; 通知</span></span><br><span class="line">            <span class="comment">// 业务，判断-&gt; 执行-&gt; 通知</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="comment">// C等待</span></span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"=&gt;CCCCC "</span>);</span><br><span class="line">            <span class="comment">// 唤醒，唤醒指定的人，A</span></span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>notify方法只唤醒一个等待（对象的）线程并使该线程开始执行。所以如果有多个线程等待一个对象，这个方法只会唤醒其中一个线程，选择哪个线程取决于操作系统对多线程管理的实现。</p>
<p>而Condition可以指定线程进行await()（等待）和Signal(唤醒)操作。(所以可以创建多个Condition来进行操作)</p>

        <h2 id="6、8锁现象"   >
          <a href="#6、8锁现象" class="heading-link"><i class="fas fa-link"></i></a>6、8锁现象</h2>
      <p>前面提出一个问题：如何判断锁的是谁！知道什么是锁，锁到底锁的是谁！</p>
<p><strong>深刻理解我们的锁</strong></p>
<p><strong>synchronized 锁的对象是方法的调用者</strong></p>
<p>1.</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 8锁，就是关于锁的8个问题</span></span><br><span class="line"><span class="comment"> * 1、标准情况下，两个线程先打印 发短信还是 先打印 打电话？ 1/发短信  2/打电话</span></span><br><span class="line"><span class="comment"> * 1、sendSms延迟4秒，两个线程先打印 发短信还是 打电话？ 1/发短信  2/打电话</span></span><br><span class="line"><span class="comment"> */</span>.</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="comment">// 锁的存在</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.sendSms();</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line">        <span class="comment">// 捕获</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.call();</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="comment">// synchronized 锁的对象是方法的调用者！、</span></span><br><span class="line">    <span class="comment">// 两个方法用的是同一个对象调用(同一个锁)，谁先拿到锁谁执行！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);<span class="comment">// 抱着锁睡眠</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"发短信"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打电话"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 先执行 发短信，后执行打电话</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li><strong>synchronized 锁的对象是方法的调用者！<br>两个方法用的是同一个对象调用(同一个锁)，谁先拿到锁谁执行！</strong></li>
</ul>
<p>2.</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3、 增加了一个普通方法后！先执行发短信还是Hello？// 普通方法</span></span><br><span class="line"><span class="comment"> * 4、 两个对象，两个同步方法， 发短信还是 打电话？ // 打电话</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 两个对象，两个调用者，两把锁！</span></span><br><span class="line">        Phone2 phone1 = <span class="keyword">new</span> Phone2();</span><br><span class="line">        Phone2 phone2 = <span class="keyword">new</span> Phone2();</span><br><span class="line">        <span class="comment">//锁的存在</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone1.sendSms();</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line">        <span class="comment">// 捕获</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone2.call();</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone2.hello();</span><br><span class="line">        &#125;,<span class="string">"C"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone2</span></span>&#123;</span><br><span class="line">    <span class="comment">// synchronized 锁的对象是方法的调用者！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"发短信"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打电话"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里没有锁！不是同步方法，不受锁的影响</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 先执行打电话，接着执行hello，最后执行发短信</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li><strong>同一个对象的话，同时调用同步方法和普通方法时</strong></li>
</ul>
<p><strong>因为普通方法没有锁！不是同步方法就不受锁的影响，正常执行</strong></p>
<ul>
<li><strong>发短信前有延时</strong></li>
</ul>
<p>3.</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 5、增加两个静态的同步方法，只有一个对象，先打印 发短信？打电话？//发短信</span></span><br><span class="line"><span class="comment"> * 6、两个对象！增加两个静态的同步方法， 先打印 发短信？打电话？//发短信</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 两个对象的Class类模板只有一个，static，锁的是Class</span></span><br><span class="line">        Phone3 phone1 = <span class="keyword">new</span> Phone3();</span><br><span class="line">        Phone3 phone2 = <span class="keyword">new</span> Phone3();</span><br><span class="line">        <span class="comment">//锁的存在</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone1.sendSms();</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line">        <span class="comment">// 捕获</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone2.call();</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Phone3唯一的一个 Class 对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone3</span></span>&#123;</span><br><span class="line">    <span class="comment">// synchronized 锁的对象是方法的调用者！</span></span><br><span class="line">    <span class="comment">// static 静态方法</span></span><br><span class="line">    <span class="comment">// 类一加载就有了！锁的是Class</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"发短信"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打电话"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 先执行发短信，后执行打电话</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li><strong>static 静态方法， 类一加载就有了！锁的是Class，是一个模板</strong></li>
</ul>
<p>4.</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 7、1个静态的同步方法，1个普通的同步方法 ，一个对象，先打印 发短信？打电话？//打电话</span></span><br><span class="line"><span class="comment"> * 8、1个静态的同步方法，1个普通的同步方法 ，两个对象，先打印 发短信？打电话？//打电话</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 两个对象的Class类模板只有一个，static，锁的是Class</span></span><br><span class="line">        Phone4 phone1 = <span class="keyword">new</span> Phone4();</span><br><span class="line">        Phone4 phone2 = <span class="keyword">new</span> Phone4();</span><br><span class="line">        <span class="comment">//锁的存在</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone1.sendSms();</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line">        <span class="comment">// 捕获</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone2.call();</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Phone3唯一的一个 Class 对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone4</span></span>&#123;</span><br><span class="line">    <span class="comment">// 静态的同步方法 锁的是 Class 类模板</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"发短信"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 普通的同步方法  锁的调用者(对象),二者锁的对象不同,所以不需要等待</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打电话"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 7/8 两种情况下，都是先执行打电话,后执行发短信,因为二者锁的对象不同,</span></span><br><span class="line"><span class="comment">// 静态同步方法锁的是Class类模板,普通同步方法锁的是实例化的对象,</span></span><br><span class="line"><span class="comment">// 所以不用等待前者解锁后 后者才能执行,而是两者并行执行,因为发短信休眠4s</span></span><br><span class="line"><span class="comment">// 所以打电话先执行。</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li><p><strong>静态的同步方法 锁的是 Class 类模板</strong></p>
</li>
<li><p><strong>普通的同步方法  锁的调用者(对象),二者锁的对象不同,所以不需要等待</strong></p>
</li>
</ul>

        <h2 id="7、集合类不安全"   >
          <a href="#7、集合类不安全" class="heading-link"><i class="fas fa-link"></i></a>7、集合类不安全</h2>
      
        <h3 id="List-不安全"   >
          <a href="#List-不安全" class="heading-link"><i class="fas fa-link"></i></a>List 不安全</h3>
      <p>*<em>List、ArrayList 等在并发多线程条件下，不能实现数据共享，多个线程同时调用一个list对象时候就会出现并发修改异常ConcurrentModificationException *</em>。</p>
<p>代码举例：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"><span class="comment">// java.util.ConcurrentModificationException 并发修改异常！</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 并发下 ArrayList 不安全的吗，Synchronized；</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 解决方案；</span></span><br><span class="line"><span class="comment">         * 方案1、List&lt;String&gt; list = new Vector&lt;&gt;();</span></span><br><span class="line"><span class="comment">         * 方案2、List&lt;String&gt; list =</span></span><br><span class="line"><span class="comment">         * Collections.synchronizedList(new ArrayList&lt;&gt;());</span></span><br><span class="line"><span class="comment">         * 方案3、List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;()；</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">       <span class="comment">/* CopyOnWrite 写入时复制  COW  计算机程序设计领域的一种优化策略；</span></span><br><span class="line"><span class="comment">        * 多个线程调用的时候，list，读取的时候，固定的，写入（覆盖）</span></span><br><span class="line"><span class="comment">        * 在写入的时候避免覆盖，造成数据问题！</span></span><br><span class="line"><span class="comment">        * 读写分离</span></span><br><span class="line"><span class="comment">        * CopyOnWriteArrayList  比 Vector Nb 在哪里？</span></span><br><span class="line"><span class="comment">        */</span>    </span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>CopyOnWrite <strong>写入时复制</strong>  COW  计算机程序设计领域的一种优化策略；</p>
<ul>
<li>多个线程调用的时候，list，读取的时候，固定的，写入（覆盖）</li>
<li>在写入的时候避免覆盖，造成数据问题！</li>
<li>读写分离</li>
<li>CopyOnWriteArrayList  比 Vector Nb 在哪里？<ul>
<li>Vector源码都是用synchronized写的，效率低，占用内存，数据一致性差</li>
</ul>
</li>
</ul>
<p>（学习方法：1.先会用，2货比三家，3.分析源码）</p>

        <h3 id="Set-不安全"   >
          <a href="#Set-不安全" class="heading-link"><i class="fas fa-link"></i></a>Set 不安全</h3>
      <p>*<em>Set、Hash 等在并发多线程条件下，不能实现数据共享，多个线程同时调用一个set对象时候就会出现并发修改异常ConcurrentModificationException *</em>。</p>
<p>代码举例：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同理可证 ： ConcurrentModificationException 并发修改异常</span></span><br><span class="line"><span class="comment"> * 1、Set&lt;String&gt; set = </span></span><br><span class="line"><span class="comment"> *                     Collections.synchronizedSet(new HashSet&lt;&gt;());</span></span><br><span class="line"><span class="comment"> * 2、</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Set&lt;String&gt; set = new HashSet&lt;&gt;();//不安全</span></span><br><span class="line">        <span class="comment">// Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());//安全</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();<span class="comment">//安全</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">30</span> ; i++) &#123;</span><br><span class="line">           <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">               set.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">               System.out.println(set);</span><br><span class="line">           &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p> <strong>HashSet 的底层就是一个HashMap</strong></p>

        <h3 id="Map-不安全"   >
          <a href="#Map-不安全" class="heading-link"><i class="fas fa-link"></i></a>Map 不安全</h3>
      <p>代码举例：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="comment">// ConcurrentModificationException</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">MapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// map 是这样用的吗？ 不是，工作中不用 HashMap</span></span><br><span class="line">        <span class="comment">// 默认等价于什么？  new HashMap&lt;&gt;(16,0.75);</span></span><br><span class="line">        <span class="comment">// Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span></span><br><span class="line">        <span class="comment">// 扩展：研究ConcurrentHashMap的原理</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                map.put(Thread.currentThread().getName(),</span><br><span class="line">                       UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(map);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



<p><span class="exturl"><a class="exturl__link"   href="https://www.kuangstudy.com/bbs/1374623200771612673"  target="_blank" rel="noopener">HashMap底层数据结构、HashMap是怎样将数组初始容量的长度转化为2的整数次幂的、为什么数组的长度必须是2的指数次幂、为什么加载因子是0.75、为什么链表长度大于等于8时转成了红黑树</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   href="https://blog.csdn.net/ym123456677/article/details/78860719"  target="_blank" rel="noopener">ConcurrentHashMap的原理</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>(锁分段技术)</p>

        <h2 id="8、Callable-简单"   >
          <a href="#8、Callable-简单" class="heading-link"><i class="fas fa-link"></i></a>8、Callable (简单)</h2>
      <img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/8.png" class="" title="图片">

<p><strong>Callable 和 Runable 对比：</strong></p>
<blockquote>
<p>举例：比如<strong>Callable</strong> 是你自己，你想通过你的女朋友 <strong>Runable *<em>认识她的闺蜜 *</em>Thread</strong></p>
</blockquote>
<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/9.png" class="" title="图片">

<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/10.png" class="" title="图片">



<ul>
<li><strong>Callable</strong> 是 java.util 包下 concurrent 下的接口，有返回值，可以抛出被检查的异常</li>
<li><strong>Runable</strong> 是 java.lang 包下的接口，没有返回值，不可以抛出被检查的异常</li>
<li>二者调用的方法不同，<strong>run</strong>()/ <strong>call</strong>()</li>
</ul>
<p>同样的 <strong>Lock</strong> 和 <strong>Synchronized</strong> 二者的区别，前者是java.util 下的接口 后者是 java.lang 下的关键字。</p>
<p><strong>代码举例</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、探究原理</span></span><br><span class="line"><span class="comment"> * 2、觉自己会用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// new Thread(new Runnable()).start();// 启动Runnable</span></span><br><span class="line">        <span class="comment">// new Thread(new FutureTask&lt;V&gt;()).start();</span></span><br><span class="line">        <span class="comment">// new Thread(new FutureTask&lt;V&gt;( Callable )).start();</span></span><br><span class="line">        <span class="keyword">new</span> Thread().start(); <span class="comment">// 怎么启动Callable？</span></span><br><span class="line">        <span class="comment">// new 一个MyThread实例</span></span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">// MyThread实例放入FutureTask</span></span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(thread); <span class="comment">// 适配类</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask,<span class="string">"A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask,<span class="string">"B"</span>).start(); <span class="comment">// call()方法结果会被缓存，提高效率，因此只打印1个call</span></span><br><span class="line">        <span class="comment">// 这个get 方法可能会产生阻塞！把他放到最后</span></span><br><span class="line">        Integer o = (Integer) futureTask.get(); </span><br><span class="line">        <span class="comment">// 或者使用异步通信来处理！</span></span><br><span class="line">        System.out.println(o);<span class="comment">// 1024</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"call()"</span>); <span class="comment">// A,B两个线程会打印几个call？（1个）</span></span><br><span class="line">        <span class="comment">// 耗时的操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//class MyThread implements Runnable &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public void run() &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println("run()"); // 会打印几个run</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></div></figure>

<p><strong>细节：</strong></p>
<p>1、有缓存(A,B两个线程会打印几个call？（1个）)</p>
<p>2、结果可能需要等待，会阻塞！</p>

        <h2 id="9、常用的辅助类-必会"   >
          <a href="#9、常用的辅助类-必会" class="heading-link"><i class="fas fa-link"></i></a>9、常用的辅助类(必会)</h2>
      
        <h3 id="9-1、CountDownLatch"   >
          <a href="#9-1、CountDownLatch" class="heading-link"><i class="fas fa-link"></i></a>9.1、CountDownLatch</h3>
      <img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/11.png" class="" title="图片">

<p><strong>减法计数器： 实现调用几次线程后 再触发某一个任务</strong></p>
<p>代码举例：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="comment">// 计数器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 总数是6，必须要执行任务的时候，再使用！</span></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">6</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()</span><br><span class="line">                                                           +<span class="string">" Go out"</span>);</span><br><span class="line">                countDownLatch.countDown(); <span class="comment">// 数量-1</span></span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await(); <span class="comment">// 等待计数器归零，然后再向下执行</span></span><br><span class="line">        System.out.println(<span class="string">"Close Door"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>原理：</p>
<p><code>countDownLatch.countDown();</code> // 数量-1</p>
<p><code>countDownLatch.await();</code> // 等待计数器归零，然后再向下执行</p>
<p>每次有线程调用 <strong>countDown</strong>() 数量-1，假设计数器变为0，<strong>countDownLatch.await</strong>() 就会被唤醒，继续执行！</p>

        <h3 id="9-2、CyclicBarrier"   >
          <a href="#9-2、CyclicBarrier" class="heading-link"><i class="fas fa-link"></i></a>9.2、CyclicBarrier</h3>
      <img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/12.png" class="" title="图片">

<p><strong>加法计数器</strong>：<strong>集齐7颗龙珠召唤神龙</strong></p>
<p>代码举例：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 集齐7颗龙珠召唤神龙</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 召唤龙珠的线程</span></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>,()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">"召唤神龙成功！"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">7</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="comment">// lambda能操作到 i 吗</span></span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()</span><br><span class="line">                                                 +<span class="string">"收集"</span>+temp+<span class="string">"个龙珠"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await(); <span class="comment">// 等待</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>虽然看上去都是倒计时，这个辅助类是通过await来计数的，await之后本次线程会阻塞，直到神龙召唤后才执行后面的。</strong></p>
<p>即：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    cyclicBarrier.await(); <span class="comment">// 等待</span></span><br><span class="line">    System.out.println(<span class="string">"你好"</span>);</span><br><span class="line">&#125;<span class="comment">//如果神龙召唤没有执行，则你好也不会输出，如果神龙召唤成功执行，则会在神龙召唤后输出7个你好</span></span><br></pre></td></tr></table></div></figure>




        <h3 id="9-3、Semaphore"   >
          <a href="#9-3、Semaphore" class="heading-link"><i class="fas fa-link"></i></a>9.3、Semaphore</h3>
      <p>Semaphore：信号量</p>
<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/13.png" class="" title="图片">

<p><strong>限流/抢车位！6车—3个停车位置</strong></p>
<p>代码举例：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程数量：停车位! 限流！、</span></span><br><span class="line">        <span class="comment">// 如果已有3个线程执行（3个车位已满），则其他线程需要等待‘车位’释放后，才能执行！</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">6</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="comment">// acquire() 得到</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread()</span><br><span class="line">                                               .getName()+<span class="string">"抢到车位"</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread()</span><br><span class="line">                                               .getName()+<span class="string">"离开车位"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release(); <span class="comment">// release() 释放 </span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>只有三个车位，只有当某辆车离开车位，车位空出来后，下一辆车才能在此停放。</p>
<p><strong>原理：</strong></p>
<p><code>semaphore.acquire();</code> 获得，假设如果已经满了，等待，等待被释放为止！</p>
<p><code>semaphore.release();</code> 释放，会将当前的信号量释放 + 1，然后唤醒等待的线程！</p>
<p>作用： 多个共享资源互斥的使用！并发限流，控制最大的线程数！</p>

        <h2 id="10、读写锁-ReadWriteLock"   >
          <a href="#10、读写锁-ReadWriteLock" class="heading-link"><i class="fas fa-link"></i></a>10、读写锁 ReadWriteLock</h2>
      <p>ReadWriteLock</p>
<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/14.png" class="" title="图片">

<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 独占锁（写锁） 一次只能被一个线程占有</span></span><br><span class="line"><span class="comment"> * 共享锁（读锁） 多个线程可以同时占有</span></span><br><span class="line"><span class="comment"> * ReadWriteLock</span></span><br><span class="line"><span class="comment"> * 读-读  可以共存！</span></span><br><span class="line"><span class="comment"> * 读-写  不能共存！</span></span><br><span class="line"><span class="comment"> * 写-写  不能共存！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//MyCache myCache = new MyCache();</span></span><br><span class="line">        MyCacheLock myCacheLock = <span class="keyword">new</span> MyCacheLock();</span><br><span class="line">        <span class="comment">// 写入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                myCacheLock.put(temp+<span class="string">""</span>,temp+<span class="string">""</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读取</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                myCacheLock.get(temp+<span class="string">""</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义缓存</span></span><br><span class="line"><span class="comment"> * 加锁的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCacheLock</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 读写锁： 更加细粒度的控制</span></span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock readWriteLock = <span class="keyword">new</span>             </span><br><span class="line">                                    ReentrantReadWriteLock();</span><br><span class="line">    <span class="comment">// private Lock lock = new ReentrantLock();</span></span><br><span class="line">    <span class="comment">// 存，写入的时候，只希望同时只有一个线程写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key,Object value)</span></span>&#123;</span><br><span class="line">        readWriteLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()</span><br><span class="line">                                                       +<span class="string">"写入"</span>+key);</span><br><span class="line">            map.put(key,value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()</span><br><span class="line">                                                       +<span class="string">"写入OK"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取，读，所有人都可以读！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        readWriteLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()</span><br><span class="line">                                                       +<span class="string">"读取"</span>+key);</span><br><span class="line">            Object o = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()</span><br><span class="line">                                                       +<span class="string">"读取OK"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义缓存</span></span><br><span class="line"><span class="comment"> * 不加锁的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 存，写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key,Object value)</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()</span><br><span class="line">                                                       +<span class="string">"写入"</span>+key);</span><br><span class="line">        map.put(key,value);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()</span><br><span class="line">                                                       +<span class="string">"写入OK"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取，读</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()</span><br><span class="line">                                                       +<span class="string">"读取"</span>+key);</span><br><span class="line">        Object o = map.get(key);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()</span><br><span class="line">                                                       +<span class="string">"读取OK"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="11、阻塞队列"   >
          <a href="#11、阻塞队列" class="heading-link"><i class="fas fa-link"></i></a>11、阻塞队列</h2>
      <img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/15.png" class="" title="图片">

<p><strong>阻塞队列：</strong></p>
<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/16.png" class="" title="图片">

<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/17.png" class="" title="图片">


        <h4 id="BlockingQueue"   >
          <a href="#BlockingQueue" class="heading-link"><i class="fas fa-link"></i></a>BlockingQueue</h4>
      <p>BlockingQueue 不是新的东西</p>
<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/18.png" class="" title="图片">

<p>什么情况下我们会使用 阻塞队列?：多线程并发处理，线程池用的较多 ！</p>
<p><strong>学会使用队列</strong></p>
<p>添加、移除</p>
<div class="table-container"><table>
<thead>
<tr>
<th>方式</th>
<th>抛出异常</th>
<th>有返回值，不抛出异常</th>
<th>阻塞 等待</th>
<th>超时等待</th>
</tr>
</thead>
<tbody><tr>
<td>添加</td>
<td>add</td>
<td>offer()</td>
<td>put()</td>
<td>offer(,)</td>
</tr>
<tr>
<td>移除</td>
<td>remove</td>
<td>poll()</td>
<td>take()</td>
<td>poll(,)</td>
</tr>
<tr>
<td>检测队首元素</td>
<td>element</td>
<td>peek()</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table></div>
<p>代码示例：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        test4();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 无返回值，抛出异常的方式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 队列的大小</span></span><br><span class="line">        ArrayBlockingQueue blockingQueue = </span><br><span class="line">                                    <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">"a"</span>));<span class="comment">// true</span></span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">"b"</span>));<span class="comment">// true</span></span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">"c"</span>));<span class="comment">// true</span></span><br><span class="line">        <span class="comment">// System.out.println(blockingQueue.add("d"));</span></span><br><span class="line">        <span class="comment">// IllegalStateException: Queue full 抛出异常---队列已满！</span></span><br><span class="line">        System.out.println(<span class="string">"==========================="</span>);</span><br><span class="line">        System.out.println(blockingQueue.element());<span class="comment">//</span></span><br><span class="line">        <span class="comment">// 查看队首元素是谁</span></span><br><span class="line">        System.out.println(blockingQueue.remove());<span class="comment">//</span></span><br><span class="line">        System.out.println(blockingQueue.remove());<span class="comment">//</span></span><br><span class="line">        System.out.println(blockingQueue.remove());<span class="comment">//</span></span><br><span class="line">        <span class="comment">// System.out.println(blockingQueue.remove());</span></span><br><span class="line">        <span class="comment">// java.util.NoSuchElementException 抛出异常---队列已为空！</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2. 有返回值，不抛出异常的方式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 队列的大小</span></span><br><span class="line">        ArrayBlockingQueue blockingQueue = </span><br><span class="line">                                    <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"a"</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"b"</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"c"</span>));</span><br><span class="line">        System.out.println(blockingQueue.peek());</span><br><span class="line">        <span class="comment">// System.out.println(blockingQueue.offer("d")); </span></span><br><span class="line">        <span class="comment">// false 不抛出异常！</span></span><br><span class="line">        System.out.println(<span class="string">"==========================="</span>);</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll()); </span><br><span class="line">        <span class="comment">// null  不抛出异常！</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3. 等待，阻塞（一直阻塞）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 队列的大小</span></span><br><span class="line">        ArrayBlockingQueue blockingQueue = </span><br><span class="line">                                    <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 一直阻塞</span></span><br><span class="line">        blockingQueue.put(<span class="string">"a"</span>);</span><br><span class="line">        blockingQueue.put(<span class="string">"b"</span>);</span><br><span class="line">        blockingQueue.put(<span class="string">"c"</span>);</span><br><span class="line">        <span class="comment">// blockingQueue.put("d"); // 队列没有位置了，一直阻塞等待</span></span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        System.out.println(blockingQueue.take()); </span><br><span class="line">        <span class="comment">// 没有这个元素，一直阻塞等待</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4. 等待，阻塞（等待超时）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 队列的大小</span></span><br><span class="line">        ArrayBlockingQueue blockingQueue = </span><br><span class="line">                                    <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        blockingQueue.offer(<span class="string">"a"</span>);</span><br><span class="line">        blockingQueue.offer(<span class="string">"b"</span>);</span><br><span class="line">        blockingQueue.offer(<span class="string">"c"</span>);</span><br><span class="line">        <span class="comment">// blockingQueue.offer("d",2,TimeUnit.SECONDS); </span></span><br><span class="line">        <span class="comment">// 等待超过2秒就退出</span></span><br><span class="line">        System.out.println(<span class="string">"==============="</span>);</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        blockingQueue.poll(<span class="number">2</span>,TimeUnit.SECONDS); <span class="comment">// 等待超过2秒就退出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="SynchronousQueue"   >
          <a href="#SynchronousQueue" class="heading-link"><i class="fas fa-link"></i></a>SynchronousQueue</h4>
      <blockquote>
<p>SynchronousQueue <strong>同步队列</strong></p>
</blockquote>
<p><strong>没有容量，进去一个元素，必须等待取出来之后，才能再往里面放一个元素！</strong></p>
<p>put、take</p>
<p>代码举例：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步队列:</span></span><br><span class="line"><span class="comment"> * 和其他的BlockingQueue 不一样， SynchronousQueue 不存储元素</span></span><br><span class="line"><span class="comment"> * put了一个元素，必须从里面先take取出来，否则不能在put进去值！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = </span><br><span class="line">                                <span class="keyword">new</span> SynchronousQueue&lt;&gt;(); <span class="comment">// 同步队列</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()</span><br><span class="line">                                                           +<span class="string">" put 1"</span>);</span><br><span class="line">                <span class="comment">// put进入一个元素</span></span><br><span class="line">                blockingQueue.put(<span class="string">"1"</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()</span><br><span class="line">                                                           +<span class="string">" put 2"</span>);</span><br><span class="line">                blockingQueue.put(<span class="string">"2"</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()</span><br><span class="line">                                                           +<span class="string">" put 3"</span>);</span><br><span class="line">                blockingQueue.put(<span class="string">"3"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"T1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 睡眠3s取出一个元素</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()</span><br><span class="line">                                           +<span class="string">"=&gt;"</span>+blockingQueue.take());</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()</span><br><span class="line">                                           +<span class="string">"=&gt;"</span>+blockingQueue.take());</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()</span><br><span class="line">                                           +<span class="string">"=&gt;"</span>+blockingQueue.take());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"T2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="12、线程池-重点"   >
          <a href="#12、线程池-重点" class="heading-link"><i class="fas fa-link"></i></a>12、线程池(重点)</h2>
      <p><strong>线程池：3大方法、7大参数、4种拒绝策略</strong></p>
<blockquote>
<p>池化技术</p>
</blockquote>
<p>程序的运行，本质：占用系统的资源！ （优化资源的使用 =&gt; 池化技术）</p>
<p>线程池、连接池、内存池、对象池///… 创建、销毁。十分浪费资源</p>
<p>池化技术：事先准备好一些资源，有人要用，就来我这里拿，用完之后还给我。</p>
<blockquote>
<p>线程池的好处:</p>
</blockquote>
<ul>
<li>1、降低系统资源的消耗</li>
<li>2、提高响应的速度</li>
<li>3、方便管理</li>
</ul>
<p><strong>线程复用、可以控制最大并发数、管理线程</strong></p>

        <h4 id="线程池：3大方法"   >
          <a href="#线程池：3大方法" class="heading-link"><i class="fas fa-link"></i></a>线程池：3大方法</h4>
      <blockquote>
<p>线程池：3大方法</p>
</blockquote>
<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/19.png" class="" title="图片">

<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Executors 工具类、3大方法</span></span><br><span class="line">        <span class="comment">// Executors.newSingleThreadExecutor();// 创建单个线程的线程池</span></span><br><span class="line">        <span class="comment">// Executors.newFixedThreadPool(5);// 创建一个固定大小的线程池</span></span><br><span class="line">        <span class="comment">// Executors.newCachedThreadPool();// 创建一个可伸缩的线程池</span></span><br><span class="line">        <span class="comment">// 单个线程的线程池</span></span><br><span class="line">        ExecutorService threadPool =     </span><br><span class="line">                                Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 使用了线程池之后，使用线程池来创建线程</span></span><br><span class="line">                threadPool.execute(()-&gt;&#123;</span><br><span class="line">                    System.out.println(</span><br><span class="line">                        Thread.currentThread().getName()+<span class="string">" ok"</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 线程池用完，程序结束，关闭线程池</span></span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="线程池：7大参数"   >
          <a href="#线程池：7大参数" class="heading-link"><i class="fas fa-link"></i></a>线程池：7大参数</h4>
      <blockquote>
<p>7大参数</p>
</blockquote>
<p>源码分析：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService (</span><br><span class="line">        <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">1</span>, </span><br><span class="line">            <span class="number">1</span>,</span><br><span class="line">            <span class="number">0L</span>, </span><br><span class="line">            TimeUnit.MILLISECONDS, </span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;())); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">        <span class="number">5</span>, </span><br><span class="line">        <span class="number">5</span>, </span><br><span class="line">        <span class="number">0L</span>, </span><br><span class="line">        TimeUnit.MILLISECONDS, </span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">        <span class="number">0</span>, </span><br><span class="line">        Integer.MAX_VALUE, </span><br><span class="line">        <span class="number">60L</span>, </span><br><span class="line">        TimeUnit.SECONDS, </span><br><span class="line">        <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;()); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 本质ThreadPoolExecutor（） </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, // 核心线程池大小 </span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize, // 最大核心线程池大小 最大线程池数量</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime, // 超时没有人调用就会释放 </span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit, // 超时单位 </span></span></span><br><span class="line"><span class="function"><span class="params">                          // 阻塞队列 </span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue, </span></span></span><br><span class="line"><span class="function"><span class="params">                          // 线程工厂：创建线程的，一般 不用动</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,  </span></span></span><br><span class="line"><span class="function"><span class="params">                          // 拒绝策略</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handle )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> </span><br><span class="line">        || maximumPoolSize &lt;= <span class="number">0</span> </span><br><span class="line">        || maximumPoolSize &lt; corePoolSize </span><br><span class="line">        || keepAliveTime &lt; <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(); </span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> </span><br><span class="line">        || threadFactory == <span class="keyword">null</span> </span><br><span class="line">        || handler == <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); </span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> </span><br><span class="line">        ? <span class="keyword">null</span> : AccessController.getContext(); </span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize; </span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize; </span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue; </span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime); </span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory; </span><br><span class="line">    <span class="keyword">this</span>.handler = handler; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/20.png" class="" title="图片">

<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/21.png" class="" title="图片">



<blockquote>
<p>手动创建一个线程池</p>
</blockquote>
<p>因为实际开发中工具类<strong>Executors</strong> 不安全，所以需要手动创建线程池，自定义7个参数。</p>
<p>示例代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="comment">// Executors 工具类、3大方法</span></span><br><span class="line"><span class="comment">// Executors.newSingleThreadExecutor();// 创建一个单个线程的线程池</span></span><br><span class="line"><span class="comment">// Executors.newFixedThreadPool(5);// 创建一个固定大小的线程池</span></span><br><span class="line"><span class="comment">// Executors.newCachedThreadPool();// 创建一个可伸缩的线程池</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 四种拒绝策略：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * new ThreadPoolExecutor.AbortPolicy() </span></span><br><span class="line"><span class="comment"> * 银行满了，还有人进来，不处理这个人的，抛出异常</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * new ThreadPoolExecutor.CallerRunsPolicy() </span></span><br><span class="line"><span class="comment"> * 哪来的去哪里！比如你爸爸 让你去通知妈妈洗衣服，妈妈拒绝，让你回去通知爸爸洗</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * new ThreadPoolExecutor.DiscardPolicy() </span></span><br><span class="line"><span class="comment"> * 队列满了，丢掉任务，不会抛出异常！</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * new ThreadPoolExecutor.DiscardOldestPolicy() </span></span><br><span class="line"><span class="comment"> * 队列满了，尝试去和最早的竞争，也不会抛出异常！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自定义线程池！工作 ThreadPoolExecutor</span></span><br><span class="line">        ExecutorService threadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">2</span>,<span class="comment">// int corePoolSize, 核心线程池大小(候客区窗口2个)</span></span><br><span class="line">                <span class="number">5</span>,<span class="comment">// int maximumPoolSize, 最大核心线程池大小(总共5个窗口) </span></span><br><span class="line">                <span class="number">3</span>,<span class="comment">// long keepAliveTime, 超时3秒没有人调用就会释，放关闭窗口 </span></span><br><span class="line">                TimeUnit.SECONDS,<span class="comment">// TimeUnit unit, 超时单位 秒 </span></span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="number">3</span>),<span class="comment">// 阻塞队列(候客区最多3人)</span></span><br><span class="line">                Executors.defaultThreadFactory(),<span class="comment">// 默认线程工厂</span></span><br><span class="line">                <span class="comment">// 4种拒绝策略之一：</span></span><br><span class="line">                <span class="comment">// 队列满了，尝试去和 最早的竞争，也不会抛出异常！</span></span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy());  </span><br><span class="line">        <span class="comment">//队列满了，尝试去和最早的竞争，也不会抛出异常！</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 最大承载：Deque + max</span></span><br><span class="line">            <span class="comment">// 超过 RejectedExecutionException</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 使用了线程池之后，使用线程池来创建线程</span></span><br><span class="line">                threadPool.execute(()-&gt;&#123;</span><br><span class="line">                    System.out.println(</span><br><span class="line">                        Thread.currentThread().getName()+<span class="string">" ok"</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 线程池用完，程序结束，关闭线程池</span></span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="线程池：4种拒绝策略"   >
          <a href="#线程池：4种拒绝策略" class="heading-link"><i class="fas fa-link"></i></a>线程池：4种拒绝策略</h4>
      <blockquote>
<p>4种拒绝策略</p>
</blockquote>
<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/22.png" class="" title="图片">

<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 四种拒绝策略：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * new ThreadPoolExecutor.AbortPolicy() </span></span><br><span class="line"><span class="comment"> * 银行满了，还有人进来，不处理这个人的，抛出异常</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * new ThreadPoolExecutor.CallerRunsPolicy() </span></span><br><span class="line"><span class="comment"> * 哪来的去哪里！比如你爸爸 让你去通知妈妈洗衣服，妈妈拒绝，让你回去通知爸爸洗</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * new ThreadPoolExecutor.DiscardPolicy() </span></span><br><span class="line"><span class="comment"> * 队列满了，丢掉任务，不会抛出异常！</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * new ThreadPoolExecutor.DiscardOldestPolicy() </span></span><br><span class="line"><span class="comment"> * 队列满了，尝试去和最早的竞争，也不会抛出异常！</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></div></figure>



<blockquote>
<p>小结和拓展</p>
</blockquote>
<p>池的最大容量如何去设置！</p>
<p>了解：<strong>IO密集型，CPU密集型：（调优）</strong></p>
<p>直接上代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自定义线程池！工作 ThreadPoolExecutor</span></span><br><span class="line">        <span class="comment">// 最大线程到底该如何定义</span></span><br><span class="line">        <span class="comment">// 1、CPU 密集型，几核，就是几，可以保持CPu的效率最高！ </span></span><br><span class="line">        <span class="comment">// 2、IO 密集型 &gt; 判断你程序中十分耗IO的线程， </span></span><br><span class="line">        <span class="comment">// 比如程序 15个大型任务 io十分占用资源！</span></span><br><span class="line">        <span class="comment">// IO密集型参数(最大线程数)就设置为大于15即可，一般选择两倍</span></span><br><span class="line">        <span class="comment">// 获取CPU的核数</span></span><br><span class="line">        System.out.println(</span><br><span class="line">            Runtime.getRuntime().availableProcessors());<span class="comment">// 8核</span></span><br><span class="line">        ExecutorService threadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">2</span>,<span class="comment">// int corePoolSize, 核心线程池大小</span></span><br><span class="line">                <span class="comment">// int maximumPoolSize, 最大核心线程池大小 8核电脑就是8</span></span><br><span class="line">                Runtime.getRuntime().availableProcessors(),</span><br><span class="line">                <span class="number">3</span>,<span class="comment">// long keepAliveTime, 超时3秒没有人调用就会释放</span></span><br><span class="line">                TimeUnit.SECONDS,<span class="comment">// TimeUnit unit, 超时单位 秒 </span></span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="number">3</span>),<span class="comment">// 阻塞队列(候客区最多3人)</span></span><br><span class="line">                Executors.defaultThreadFactory(),<span class="comment">// 默认线程工厂</span></span><br><span class="line">                <span class="comment">// 4种拒绝策略之一：</span></span><br><span class="line">                <span class="comment">// 队列满了，尝试去和 最早的竞争，也不会抛出异常！</span></span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy());  </span><br><span class="line">        <span class="comment">//队列满了，尝试去和最早的竞争，也不会抛出异常！</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 最大承载：Deque + max</span></span><br><span class="line">            <span class="comment">// 超过 RejectedExecutionException</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 使用了线程池之后，使用线程池来创建线程</span></span><br><span class="line">                threadPool.execute(()-&gt;&#123;</span><br><span class="line">                    System.out.println(</span><br><span class="line">                        Thread.currentThread().getName()+<span class="string">" ok"</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 线程池用完，程序结束，关闭线程池</span></span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="13、四大函数式接口（必需掌握）"   >
          <a href="#13、四大函数式接口（必需掌握）" class="heading-link"><i class="fas fa-link"></i></a>13、四大函数式接口（必需掌握）</h2>
      <p>新时代的程序员：lambda表达式、链式编程、函数式接口、Stream流式计算</p>
<blockquote>
<p>函数式接口： 只有一个方法的接口</p>
</blockquote>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>; </span><br><span class="line">&#125;<span class="comment">// 泛型、枚举、反射 </span></span><br><span class="line"><span class="comment">// lambda表达式、链式编程、函数式接口、Stream流式计算</span></span><br><span class="line"><span class="comment">// 超级多FunctionalInterface </span></span><br><span class="line"><span class="comment">// 简化编程模型，在新版本的框架底层大量应用！</span></span><br><span class="line"><span class="comment">// foreach(消费者类的函数式接口)</span></span><br></pre></td></tr></table></div></figure>




        <h4 id="Function-函数式接口"   >
          <a href="#Function-函数式接口" class="heading-link"><i class="fas fa-link"></i></a>Function 函数式接口</h4>
      <blockquote>
<p>Function函数式接口</p>
</blockquote>
<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/23.png" class="" title="图片">

<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function 函数型接口, 有一个输入参数，有一个输出参数</span></span><br><span class="line"><span class="comment"> * 只要是 函数型接口 可以 用 lambda表达式简化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">/*Function&lt;String,String&gt; function = new </span></span><br><span class="line"><span class="comment">                                        Function&lt;String,String&gt;() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public String apply(String str) &#123;</span></span><br><span class="line"><span class="comment">                return str;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;;*/</span></span><br><span class="line">        <span class="comment">// lambda 表达式简化：</span></span><br><span class="line">        Function&lt;String,String&gt; function = str-&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> str;&#125;;</span><br><span class="line">        System.out.println(function.apply(<span class="string">"asd"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="Predicate-断定型接口"   >
          <a href="#Predicate-断定型接口" class="heading-link"><i class="fas fa-link"></i></a>Predicate 断定型接口</h4>
      <blockquote>
<p>断定型接口：有一个输入参数，返回值只能是 布尔值！</p>
</blockquote>
<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/24.png" class="" title="图片">

<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 断定型接口：有一个输入参数，返回值只能是 布尔值！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断字符串是否为空</span></span><br><span class="line">        <span class="comment">/*Predicate&lt;String&gt; predicate = new Predicate&lt;String&gt;()&#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public boolean test(String str) &#123;</span></span><br><span class="line"><span class="comment">                return str.isEmpty();//true或false</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;;*/</span></span><br><span class="line">        Predicate&lt;String&gt; predicate = </span><br><span class="line">                            (str)-&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> str.isEmpty(); &#125;;</span><br><span class="line">        System.out.println(predicate.test(<span class="string">""</span>));<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="Consumer-消费型接口"   >
          <a href="#Consumer-消费型接口" class="heading-link"><i class="fas fa-link"></i></a>Consumer 消费型接口</h4>
      <blockquote>
<p>Consumer 消费型接口</p>
</blockquote>
<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/25.png" class="" title="图片">

<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Consumer 消费型接口: 只有输入，没有返回值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public void accept(String str) &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(str);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;;*/</span></span><br><span class="line">        Consumer&lt;String&gt; consumer = </span><br><span class="line">                                (str)-&gt;&#123;</span><br><span class="line">    System.out.println(str);&#125;;</span><br><span class="line">        consumer.accept(<span class="string">"sdadasd"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="Supplier-供给型接口"   >
          <a href="#Supplier-供给型接口" class="heading-link"><i class="fas fa-link"></i></a>Supplier 供给型接口</h4>
      <blockquote>
<p>Supplier 供给型接口</p>
<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/26.png" class="" title="图片">
</blockquote>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Supplier 供给型接口 没有参数，只有返回值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*Supplier supplier = new Supplier&lt;Integer&gt;() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public Integer get() &#123;</span></span><br><span class="line"><span class="comment">                System.out.println("get()");</span></span><br><span class="line"><span class="comment">                return 1024;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;;*/</span></span><br><span class="line">        Supplier supplier = ()-&gt;&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1024</span>; &#125;;</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="14、Stream-流式计算"   >
          <a href="#14、Stream-流式计算" class="heading-link"><i class="fas fa-link"></i></a>14、Stream 流式计算</h2>
      <blockquote>
<p>什么是Stream流式计算</p>
</blockquote>
<p>大数据：存储 + 计算</p>
<p>集合、MySQL 本质就是存储东西的；</p>
<p>计算都应该交给流来操作！</p>
<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/27.png" class="" title="图片">

<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目要求：一分钟内完成此题，只能用一行代码实现！</span></span><br><span class="line"><span class="comment"> * 现在有5个用户！筛选：</span></span><br><span class="line"><span class="comment"> * 1、ID 必须是偶数</span></span><br><span class="line"><span class="comment"> * 2、年龄必须大于23岁</span></span><br><span class="line"><span class="comment"> * 3、用户名转为大写字母</span></span><br><span class="line"><span class="comment"> * 4、用户名字母倒着排序</span></span><br><span class="line"><span class="comment"> * 5、只输出一个用户！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User u1 = <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">"a"</span>,<span class="number">21</span>);</span><br><span class="line">        User u2 = <span class="keyword">new</span> User(<span class="number">2</span>,<span class="string">"b"</span>,<span class="number">22</span>);</span><br><span class="line">        User u3 = <span class="keyword">new</span> User(<span class="number">3</span>,<span class="string">"c"</span>,<span class="number">23</span>);</span><br><span class="line">        User u4 = <span class="keyword">new</span> User(<span class="number">4</span>,<span class="string">"d"</span>,<span class="number">24</span>);</span><br><span class="line">        User u5 = <span class="keyword">new</span> User(<span class="number">6</span>,<span class="string">"e"</span>,<span class="number">25</span>);</span><br><span class="line">        <span class="comment">// 集合就是存储</span></span><br><span class="line">        List&lt;User&gt; list = Arrays.asList(u1, u2, u3, u4, u5);</span><br><span class="line">        <span class="comment">// 计算交给Stream流</span></span><br><span class="line">        <span class="comment">// lambda表达式、链式编程、函数式接口、Stream流式计算</span></span><br><span class="line">        list.stream()</span><br><span class="line">                .filter(u-&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> u.getId()%<span class="number">2</span>==<span class="number">0</span>;&#125;)<span class="comment">// ID 必须是偶数</span></span><br><span class="line">                .filter(u-&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> u.getAge()&gt;<span class="number">23</span>;&#125;)<span class="comment">// 年龄必须大于23岁</span></span><br><span class="line">                <span class="comment">// 用户名转为大写字母</span></span><br><span class="line">                .map(u-&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> u.getName().toUpperCase();&#125;)</span><br><span class="line">                <span class="comment">// 用户名字母倒着排序</span></span><br><span class="line">                .sorted((uu1,uu2)-&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> uu2.compareTo(uu1);&#125;)</span><br><span class="line">                .limit(<span class="number">1</span>)<span class="comment">// 只输出一个用户！</span></span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="15、ForkJoin"   >
          <a href="#15、ForkJoin" class="heading-link"><i class="fas fa-link"></i></a>15、ForkJoin</h2>
      <blockquote>
<p>什么是 ForkJoin</p>
</blockquote>
<p>ForkJoin 在 JDK 1.7 ， 并行执行任务！提高效率。大数据量！</p>
<p>大数据：Map Reduce （把大任务拆分为小任务）</p>
<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/28.png" class="" title="图片">

<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/29.png" class="" title="图片">

<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/30.png" class="" title="图片">

<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/31.png" class="" title="图片">

<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求和计算的任务！</span></span><br><span class="line"><span class="comment"> * 3000   6000（ForkJoin）  9000（Stream并行流）</span></span><br><span class="line"><span class="comment"> * // 如何使用 forkjoin</span></span><br><span class="line"><span class="comment"> * // 1、forkjoinPool 通过它来执行</span></span><br><span class="line"><span class="comment"> * // 2、计算任务 forkjoinPool.execute(ForkJoinTask task)</span></span><br><span class="line"><span class="comment"> * // 3. 计算类要继承 RecursiveTask(递归任务，有返回值的)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinDemo</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long start;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">private</span> Long end;    <span class="comment">// 1990900000</span></span><br><span class="line">    <span class="comment">// 临界值</span></span><br><span class="line">    <span class="keyword">private</span> Long temp = <span class="number">10000L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinDemo</span><span class="params">(Long start, Long end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((end-start)&lt;temp)&#123;</span><br><span class="line">            Long sum = <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">for</span> (Long i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// forkjoin 递归</span></span><br><span class="line">            <span class="keyword">long</span> middle = (start + end) / <span class="number">2</span>; <span class="comment">// 中间值</span></span><br><span class="line">            ForkJoinDemo task1 = <span class="keyword">new</span> ForkJoinDemo(start, middle);</span><br><span class="line">            task1.fork(); <span class="comment">// 拆分任务，把任务压入线程队列</span></span><br><span class="line">            ForkJoinDemo task2 = <span class="keyword">new</span> ForkJoinDemo(middle+<span class="number">1</span>, end);</span><br><span class="line">            task2.fork(); <span class="comment">// 拆分任务，把任务压入线程队列</span></span><br><span class="line">            <span class="keyword">return</span> task1.join() + task2.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>测试代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinTask;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.LongStream;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同一个任务，别人效率高你几十倍！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// test1(); // 12224</span></span><br><span class="line">        <span class="comment">// test2(); // 10038</span></span><br><span class="line">        <span class="comment">// test3(); // 153</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 普通程序员</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Long sum = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (Long i = <span class="number">1L</span>; i &lt;= <span class="number">10_0000_0000</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"sum="</span>+sum+<span class="string">" 时间："</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 会使用ForkJoin</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> ForkJoinDemo(</span><br><span class="line">                                                <span class="number">0L</span>, <span class="number">10_0000_0000L</span>);</span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(task);</span><br><span class="line">        Long sum = submit.get();<span class="comment">// 获得结果</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"sum="</span>+sum+<span class="string">" 时间："</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// Stream并行流 ()  (]</span></span><br><span class="line">        <span class="keyword">long</span> sum = LongStream</span><br><span class="line">            .rangeClosed(<span class="number">0L</span>, <span class="number">10_0000_0000L</span>) <span class="comment">// 计算范围(,]</span></span><br><span class="line">            .parallel() <span class="comment">// 并行计算</span></span><br><span class="line">            .reduce(<span class="number">0</span>, Long::sum); <span class="comment">// 输出结果</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"sum="</span>+<span class="string">"时间："</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="16、异步回调"   >
          <a href="#16、异步回调" class="heading-link"><i class="fas fa-link"></i></a>16、异步回调</h2>
      <p>防止阻塞</p>
<blockquote>
<p>Future 设计的初衷： 对将来的某个事件的结果进行建模</p>
</blockquote>
<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/32.png" class="" title="图片">

<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步调用： CompletableFuture</span></span><br><span class="line"><span class="comment"> * 异步执行</span></span><br><span class="line"><span class="comment"> * 成功回调</span></span><br><span class="line"><span class="comment"> * 失败回调</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 没有返回值的 runAsync 异步回调</span></span><br><span class="line"><span class="comment">//        CompletableFuture&lt;Void&gt; completableFuture = </span></span><br><span class="line"><span class="comment">//                                    CompletableFuture.runAsync(()-&gt;&#123;</span></span><br><span class="line"><span class="comment">//            try &#123;</span></span><br><span class="line"><span class="comment">//                TimeUnit.SECONDS.sleep(2);</span></span><br><span class="line"><span class="comment">//            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//                e.printStackTrace();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            System.out.println(</span></span><br><span class="line"><span class="comment">//                Thread.currentThread().getName()+"runAsync=&gt;Void");</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println("1111");</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        completableFuture.get(); // 获取阻塞执行结果</span></span><br><span class="line">        <span class="comment">// 有返回值的 supplyAsync 异步回调</span></span><br><span class="line">        <span class="comment">// ajax，成功和失败的回调</span></span><br><span class="line">        <span class="comment">// 返回的是错误信息；</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture = </span><br><span class="line">                                CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()</span><br><span class="line">                                           +<span class="string">"supplyAsync=&gt;Integer"</span>);</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(completableFuture.whenComplete((t, u) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"t=&gt;"</span> + t); <span class="comment">// 正常的返回结果</span></span><br><span class="line">            System.out.println(<span class="string">"u=&gt;"</span> + u); </span><br><span class="line">            <span class="comment">// 错误信息：</span></span><br><span class="line">            <span class="comment">// java.util.concurrent.CompletionException: </span></span><br><span class="line">            <span class="comment">// java.lang.ArithmeticException: / by zero</span></span><br><span class="line">        &#125;).exceptionally((e) -&gt; &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">233</span>; <span class="comment">// 可以获取到错误的返回结果</span></span><br><span class="line">        &#125;).get());</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * succee Code 200</span></span><br><span class="line"><span class="comment">         * error Code 404 500</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>






        <h2 id="17、JMM"   >
          <a href="#17、JMM" class="heading-link"><i class="fas fa-link"></i></a>17、JMM</h2>
      <blockquote>
<p>请你谈谈你对 Volatile 的理解</p>
</blockquote>
<p><strong>Volatile</strong> 是 Java 虚拟机提供<strong>轻量级的同步机制</strong>，类似于<strong>synchronized</strong> 但是没有其强大。</p>
<p>1、保证可见性</p>
<p><strong>2、不保证原子性</strong></p>
<p>3、防止指令重排</p>
<blockquote>
<p>什么是JMM</p>
</blockquote>
<p>JMM ： Java内存模型，不存在的东西，概念！约定！</p>
<p><strong>关于JMM的一些同步的约定：</strong></p>
<p>1、线程解锁前，必须把共享变量<strong>立刻</strong>刷回主存。</p>
<p>2、线程加锁前，必须读取主存中的最新值到工作内存中！</p>
<p>3、加锁和解锁是同一把锁。</p>
<p>线程 <strong>工作内存</strong> 、<strong>主内存</strong></p>
<p><strong>8 种操作：</strong></p>
<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/33.png" class="" title="图片">

<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/34.png" class="" title="图片">

<p><strong>内存交互操作有8种，虚拟机实现必须保证每一个操作都是原子的，不可在分的（对于double和long类型的变量来说，load、store、read和writ操作在某些平台上允许例外）</strong></p>
<ul>
<li>lock （锁定）：作用于主内存的变量，把一个变量标识为线程独占状态</li>
<li>unlock （解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li>
<li>read （读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用</li>
<li>load （载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中</li>
<li>use （使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令</li>
<li>assign （赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中</li>
<li>store （存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用</li>
<li>write （写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中</li>
</ul>
<p><strong>JMM 对这八种指令的使用，制定了如下规则：</strong></p>
<ul>
<li><strong>不允许read和load、store和write操作之一单独出现</strong>。即使用了read必须load，使用了store必须write</li>
<li><strong>不允许线程丢弃他最近的assign操作</strong>，即工作变量的数据改变了之后，<strong>必须告知主存</strong></li>
<li>不允许一个线程将没有assign的数据从工作内存同步回主内存</li>
<li><strong>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量</strong>。就是对变量实施use、store操作之前，必须经过assign和load操作</li>
<li><strong>一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁</strong></li>
<li>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值</li>
<li>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量</li>
<li>对一个变量进行unlock操作之前，必须把此变量同步回主内存</li>
</ul>
<p><strong>问题： 程序不知道主内存的值已经被修改过了</strong></p>
<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/35.png" class="" title="图片">




        <h2 id="18、Volatile"   >
          <a href="#18、Volatile" class="heading-link"><i class="fas fa-link"></i></a>18、Volatile</h2>
      
        <h4 id="1、保证可见性"   >
          <a href="#1、保证可见性" class="heading-link"><i class="fas fa-link"></i></a>1、保证可见性</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JMMDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不加 volatile 程序就会死循环！</span></span><br><span class="line">    <span class="comment">// 加 volatile 可以保证可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// main</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">     <span class="comment">// 线程 1 对主内存的变化不知道的</span></span><br><span class="line">            <span class="keyword">while</span> (num==<span class="number">0</span>)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        num = <span class="number">1</span>;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="不保证原子性"   >
          <a href="#不保证原子性" class="heading-link"><i class="fas fa-link"></i></a>不保证原子性</h4>
      <p>原子性 : 不可分割</p>
<p>线程A在执行任务的时候，不能被打扰的，也不能被分割。要么同时成功，要么同时失败。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="comment">// volatile 不保证原子性</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VDemo02</span> </span>&#123;</span><br><span class="line">    <span class="comment">// volatile 不保证原子性</span></span><br><span class="line">    <span class="comment">// 原子类的 Integer</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> AtomicInteger num = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// num++; // 不是一个原子性操作</span></span><br><span class="line">        num.getAndIncrement(); <span class="comment">// AtomicInteger + 1 方法， CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//理论上num结果应该为 2 万</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span> ; j++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断只要剩下的线程不大于2个，就说明20个创建的线程已经执行结束</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount()&gt;<span class="number">2</span>)&#123;</span><br><span class="line">     <span class="comment">// Java 默认有 main gc 2个线程</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() </span><br><span class="line">                                                       + <span class="string">" "</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>如果不加</strong> <strong>lock</strong> <strong>和</strong> <strong>synchronized</strong> <strong>，怎么样保证原子性</strong></p>
<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/36.png" class="" title="图片">

<p>使用原子类，解决原子性问题。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// volatile 不保证原子性</span></span><br><span class="line"> <span class="comment">// 原子类的 Integer</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> AtomicInteger num = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// num++; // 不是一个原子性操作</span></span><br><span class="line">    num.getAndIncrement(); <span class="comment">// AtomicInteger + 1 方法， CAS</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></div></figure>

<p>这些类的底层都直接和操作系统挂钩！在内存中修改值！Unsafe类是一个很特殊的存在！</p>

        <h4 id="指令重排"   >
          <a href="#指令重排" class="heading-link"><i class="fas fa-link"></i></a>指令重排</h4>
      <p>什么是指令重排？：<strong>我们写的程序，计算机并不是按照你写的那样去执行的。</strong></p>
<p>源代码 —&gt; 编译器优化的重排 —&gt; 指令并行也可能会重排 —&gt; 内存系统也会重排 ——&gt; 执行</p>
<p><strong>处理器在执行指令重排的时候，会考虑：数据之间的依赖性</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">int</span> y = <span class="number">2</span>; <span class="comment">// 2</span></span><br><span class="line">x = x + <span class="number">5</span>; <span class="comment">// 3</span></span><br><span class="line">y = x * x; <span class="comment">// 4</span></span><br></pre></td></tr></table></div></figure>

<p>我们所期望的：1234 但是可能执行的时候会变成 2134 或者 1324</p>
<p>但是不可能是 4123！</p>
<p>前提：a b x y 这四个值默认都是 0：</p>
<p>可能造成影响得到不同的结果：</p>
<div class="table-container"><table>
<thead>
<tr>
<th>线程A</th>
<th>线程B</th>
</tr>
</thead>
<tbody><tr>
<td>x = a</td>
<td>y = b</td>
</tr>
<tr>
<td>b = 1</td>
<td>a =2</td>
</tr>
</tbody></table></div>
<p>正常的结果：x = 0; y =0 ; 但是可能由于指令重排出现以下结果：</p>
<div class="table-container"><table>
<thead>
<tr>
<th>线程A</th>
<th>线程B</th>
</tr>
</thead>
<tbody><tr>
<td>b = 1</td>
<td>a = 2</td>
</tr>
<tr>
<td>x = a</td>
<td>y = b</td>
</tr>
</tbody></table></div>
<p>指令重排导致的诡异结果： x = 2; y = 1;</p>
<p><strong>volatile</strong> 可以避免指令重排：</p>
<p>内存屏障。CPU指令。作用：</p>
<ol>
<li><strong>保证特定操作的执行顺序！</strong></li>
<li><strong>可以保证某些变量的内存可见性</strong> (利用这些特性<strong>volatile</strong> 实现了可见性)</li>
</ol>
<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/37.png" class="" title="图片">

<p><strong>volatile 是可以保证可见性。不能保证原子性，由于内存屏障，可以保证避免指令重排的现象产生！</strong></p>
<p><strong>volatile 内存屏障在单例模式中使用的最多！</strong></p>

        <h2 id="19、彻底玩转单例模式"   >
          <a href="#19、彻底玩转单例模式" class="heading-link"><i class="fas fa-link"></i></a>19、彻底玩转单例模式</h2>
      <p><strong>饿汉式</strong> <strong>DCL懒汉式</strong>，深究！</p>

        <h4 id="饿汉式"   >
          <a href="#饿汉式" class="heading-link"><i class="fas fa-link"></i></a>饿汉式</h4>
      <p>在类加载时就创建对象，由于在类加载时就创建单例，因此不存在线程安全问题</p>
<p>但饿汉式也存在一定的问题，即如果在该类里面存在大量开辟空间的语句，如很多数组或集合，但又不马上使用他们，这时这样的单例模式会消耗大量的内存，影响性能</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JUC.DanLi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hungry</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Hungry</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">final</span> <span class="keyword">static</span> Hungry HUNGRY= <span class="keyword">new</span> Hungry();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Hungry <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HUNGRY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Hungry.getInstance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="懒汉式"   >
          <a href="#懒汉式" class="heading-link"><i class="fas fa-link"></i></a>懒汉式</h4>
      <p>在类加载时并不会立马创建单例对象，而是只生成一个单例的引用，即可以延时加载</p>
<p>懒汉式使用同步锁锁住了整个方法，效率较低</p>

        <h5 id="懒汉式-单线程版本"   >
          <a href="#懒汉式-单线程版本" class="heading-link"><i class="fas fa-link"></i></a>懒汉式-单线程版本</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//私有化构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只提供一个实例，并不创建对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo2 instance;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonDemo2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo2Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SingletonDemo2 instance = SingletonDemo2.getInstance();</span><br><span class="line">        SingletonDemo2 instance1 = SingletonDemo2.getInstance();</span><br><span class="line">        System.out.println(instance == instance1); <span class="comment">//输出true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>分析线程不安全原因：</p>
<p>多个线程判断了instance == null,但是还没有执行初始化语句，所以导致多个线程创建多个对象。</p>
<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/38.png" class="" title="图片">

<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/39.png" class="" title="图片">




        <h5 id="懒汉式-多线程-低性能版"   >
          <a href="#懒汉式-多线程-低性能版" class="heading-link"><i class="fas fa-link"></i></a>懒汉式-多线程-低性能版</h5>
      <p>单线程版本既然是在getInstance()方法里面出现了线程不安全，那么可以怎么解决？<strong>直接给getInstance()方法加上锁synchronized就好了</strong>，但是加锁会影响效率，懒汉想吃饭了想进饭店进不去，被前面的霸道客人直接锁住了，不管有没有菜都得等着。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式单例,多线程版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lazy</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先做好准备，啥时候想吃再做。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lazy instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Lazy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"ok"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//饿了，但是发现饭馆里有人，而且只能一个人进去，只能等待</span></span><br><span class="line">     <span class="comment">//提供公共的获取方法,因为不是在类加载时就创建对象，因此存在线程安全问题，使用synchronized关键字保证线程安全，效率降低</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Lazy <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Lazy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//多线程下是安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                Lazy.getInstance();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>会有指令重排问题，所以要加volatile</p>
<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/40.png" class="" title="图片">




        <h5 id="DCL懒汉式-双重检测锁模式"   >
          <a href="#DCL懒汉式-双重检测锁模式" class="heading-link"><i class="fas fa-link"></i></a>DCL懒汉式(双重检测锁模式)</h5>
      
        <h5 id="增加volatile"   >
          <a href="#增加volatile" class="heading-link"><i class="fas fa-link"></i></a>增加volatile</h5>
      <p>同样是在类加载时只提供一个引用，不会直接创建单例对象，不需要对整个方法进行同步，<strong>缩小了锁的范围，只有第一次会进入创建对象的方法，提高了效率</strong></p>
<p>刚才低性能版是把饭店直接锁住了，所以懒汉也不知道厨房有没有做好菜，那么双重校验锁就是让客人们都可以进入饭店，询问服务员有没有做好菜（ if(instance == null) )，服务员如果说做好了(false)，直接上菜（return），如果说没有做好(true)，前面有人(厨房上锁)，则等待，前面没人，则进入厨房，上锁，做菜(初始化)。</p>
<blockquote>
<p><span class="exturl"><a class="exturl__link"   href="https://www.kuangstudy.com/bbs/1351835438947549185"  target="_blank" rel="noopener">参考资料</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JUC.DanLi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyMan</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyMan</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"ok"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazyMan lazyMan;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//双重检测锁模式 的懒汉式单例子 DCL懒汉式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyMan <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lazyMan==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyMan<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(lazyMan==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    lazyMan = <span class="keyword">new</span> LazyMan();<span class="comment">//不是一个原子操作</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     计算机指令执行顺序：</span></span><br><span class="line"><span class="comment">                     * 1. 分配内存空间</span></span><br><span class="line"><span class="comment">                     * 2、执行构造方法，初始化对象</span></span><br><span class="line"><span class="comment">                     * 3、把这个对象指向这个空间</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     * 期望顺序是：123</span></span><br><span class="line"><span class="comment">                     * 特殊情况下实际执行：132  ===&gt;  此时 A 线程没有问题</span></span><br><span class="line"><span class="comment">                     *                               若额外加一个 B 线程</span></span><br><span class="line"><span class="comment">                     *                               此时lazyMan还没有完成构造</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lazyMan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">               LazyMan.getInstance();</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DCL懒汉式(双重检测锁模式)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo3</span> </span>&#123;</span><br><span class="line">    <span class="comment">//私有化构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只提供一个实例，并不创建对象</span></span><br><span class="line">    <span class="comment">//使用避免指令重排带来的线程安全问题</span></span><br><span class="line">    <span class="comment">//volatile：对于同一个变量，在一个线程中值发生了改变，则在另一个线程中立即生效，可以大幅度避免下面的问题，不排除极端情况</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingletonDemo3 instance;</span><br><span class="line">    <span class="comment">//提供公共的获取方法,因为不是在类加载时就创建对象，因此存在线程安全问题，使用同步代码块提高效率</span></span><br><span class="line">    <span class="comment">//现在不需要对整个方法进行同步，缩小了锁的范围，只有第一次会进入创建对象的方法，提高了效率</span></span><br><span class="line">    <span class="comment">//当第一个线程执行到创建对象的方法时，但还未出方法返回，此时第二个线程进入，发现instance不为空，但第一个线程此时还未出去，可能发送意想不到的安全问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonDemo3<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonDemo3();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo3Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SingletonDemo3 instance = SingletonDemo3.getInstance();</span><br><span class="line">        SingletonDemo3 instance1 = SingletonDemo3.getInstance();</span><br><span class="line">        System.out.println(instance == instance1); <span class="comment">//输出true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="登记式-静态内部类"   >
          <a href="#登记式-静态内部类" class="heading-link"><i class="fas fa-link"></i></a>登记式/静态内部类</h4>
      <p>使用静态内部类方式能达到双重校验锁一样的功效，并且实现起来更简单。<strong>对静态域使用延迟初始化</strong>，应使用这种方式而不是双重校验锁方式。</p>
<p>使用静态内部类解决了线程安全问题，并实现了延时加载</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态内部类实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不会在外部类初始化时就直接加载，只有当调用了getInstance方法时才会静态加载，线程安全，final保证了在内存中只有一份</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonDemo4 instance = <span class="keyword">new</span> SingletonDemo4();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo4Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SingletonDemo4 instance = SingletonDemo4.getInstance();</span><br><span class="line">        SingletonDemo4 instance1 = SingletonDemo4.getInstance();</span><br><span class="line">        System.out.println(instance == instance1); <span class="comment">//输出true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="反射破坏单例"   >
          <a href="#反射破坏单例" class="heading-link"><i class="fas fa-link"></i></a>反射破坏单例</h4>
      <p>有人上锁就有人撬，反射也是可以创建对象的，并可以消除权限检验，那么接下来就演示一下用反射破坏双重校验锁。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="comment">//反射破解双重校验锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lazy2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Lazy2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Lazy2 instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Lazy2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Lazy2<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Lazy2();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反射破解</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//用单例模式创建对象</span></span><br><span class="line">        Lazy2 instance = Lazy2.getInstance();</span><br><span class="line">        <span class="comment">//通过反射获取构造器</span></span><br><span class="line">        Constructor&lt;Lazy2&gt; declaredConstructor = Lazy2<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>(<span class="title">null</span>)</span>;</span><br><span class="line">        <span class="comment">//消除构造器权限检验</span></span><br><span class="line">        declaredConstructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//构造对象</span></span><br><span class="line">        Lazy2 instance1 = declaredConstructor.newInstance();</span><br><span class="line">        <span class="comment">//通过两个对象的hashCode值来对比是否为同一对象</span></span><br><span class="line">        System.out.println(instance.hashCode());</span><br><span class="line">        System.out.println(instance1.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行结果：</p>
<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/41.png" class="" title="图片">

<p>通过构造方法创建的对象不同</p>
<p>解决：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在私有构造方法里面加锁，三重检测</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyMan</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LayeMan&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(LazyMan<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(lazyMan!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"不要试图使用反射破坏异常"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>新的问题</p>
<p>两个对象都通过反射创建</p>
<p>解决：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个标志位</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyMan</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> qinjiang = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> LayeMan&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(LazyMan<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(qinjiang==<span class="keyword">false</span>)&#123;</span><br><span class="line">                qinjiang=<span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;         </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"不要试图使用反射破坏异常"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>新的问题</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反射改变标志位，破坏私有权限</span></span><br><span class="line">Field qinjiang = LazyMan.class.getDeclaredField("qingjiang");</span><br><span class="line">qinjiang.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">qinjiang.set(instance,<span class="keyword">false</span>);</span><br></pre></td></tr></table></div></figure>




        <h2 id="枚举式"   >
          <a href="#枚举式" class="heading-link"><i class="fas fa-link"></i></a>枚举式</h2>
      <p>严格意义上来说以上四种方式实现的单例模式都不是线程安全的，因为反射机制的存在，反射可以破坏私有属性，并且通过反射创建对象，</p>
<p>枚举式不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="comment">// enum 是一个什么？ 本身也是一个Class类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumSingle &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> EnumSingle <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



<p>举个例子，通过反射破坏上面的静态内部类方式实现的单例模式</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="comment">// enum 是一个什么？ 本身也是一个Class类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumSingle &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> EnumSingle <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;</span><br><span class="line">        EnumSingle instance1 = EnumSingle.INSTANCE;</span><br><span class="line">        Constructor&lt;EnumSingle&gt; declaredConstructor = EnumSingle<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>(<span class="title">null</span>)</span>;</span><br><span class="line">        declaredConstructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        EnumSingle instance2 = declaredConstructor.newInstance();</span><br><span class="line">        <span class="comment">// NoSuchMethodException: com.kuang.single.EnumSingle.&lt;init&gt;()</span></span><br><span class="line">        System.out.println(instance1);</span><br><span class="line">        System.out.println(instance2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>会抛出Exception in thread “main” java.lang.NoSuchMethodException，欺骗，可以用JAD反编译</p>
<p>反编译出来是一个有参构造器</p>
<p>反编译源码：</p>
<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/42.png" class="" title="图片">



<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EnumSingle<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>(<span class="title">null</span>)</span>;</span><br><span class="line"><span class="comment">//改为</span></span><br><span class="line">EnumSingle<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructorString</span>.<span class="title">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;</span><br></pre></td></tr></table></div></figure>

<p>会抛出java.lang.IllegalArgumentException: Cannot reflectively create enum objects</p>
<p>(反射不能破坏枚举的单例)</p>
<p>枚举式不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。</p>

        <h2 id="20、深入理解CAS"   >
          <a href="#20、深入理解CAS" class="heading-link"><i class="fas fa-link"></i></a>20、深入理解CAS</h2>
      <blockquote>
<p>什么是 CAS</p>
</blockquote>
<p>大厂你必须要深入研究底层！有所突破！ <strong>修内功，操作系统，计算机网络原理</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// CAS compareAndSet : 比较并交换！ </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">2020</span>); </span><br><span class="line">        <span class="comment">// 期望、更新 </span></span><br><span class="line">        <span class="comment">// public final boolean compareAndSet</span></span><br><span class="line">        <span class="comment">//                                    (int expect, int update) </span></span><br><span class="line">        <span class="comment">// 如果我期望的值达到了，那么就更新，否则，</span></span><br><span class="line">        <span class="comment">// 就不更新, CAS 是CPU的并发原语！ </span></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">2020</span>, <span class="number">2021</span>)); </span><br><span class="line">        System.out.println(atomicInteger.get()); </span><br><span class="line">        atomicInteger.getAndIncrement() <span class="comment">// 看底层如何实现 ++ </span></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">2020</span>, <span class="number">2021</span>)); </span><br><span class="line">        System.out.println(atomicInteger.get()); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/43.png" class="" title="图片">

<p>valueOffset(内存地址偏移值)</p>
<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/44.png" class="" title="图片">

<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/45.png" class="" title="图片">

<p>CAS ： 比较当前工作内存中的值和主内存中的值，如果这个值是期望的，那么则执行操作！如果不是就</p>
<p>一直循环！</p>
<blockquote>
<p>CAS ： ABA 问题（狸猫换太子）</p>
</blockquote>
<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/46.png" class="" title="图片">

<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// CAS compareAndSet : 比较并交换！ </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">2020</span>); </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 类似于我们平时写的SQL：乐观锁</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 如果某个线程在执行操作某个对象的时候，其他线程若操作了该对象，</span></span><br><span class="line"><span class="comment">         * 即使对象内容未发生变化，也需要告诉我。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 期望、更新：</span></span><br><span class="line"><span class="comment">         * public final boolean compareAndSet(int </span></span><br><span class="line"><span class="comment">         *                                    expect, int update) </span></span><br><span class="line"><span class="comment">         * 如果我期望的值达到了，那么就更新，否则，就不更新, </span></span><br><span class="line"><span class="comment">         *                                    CAS 是CPU的并发原语！ </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// ============== 捣乱的线程 ================== </span></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">2020</span>, <span class="number">2021</span>)); </span><br><span class="line">        System.out.println(atomicInteger.get()); </span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">2021</span>, <span class="number">2020</span>)); </span><br><span class="line">        System.out.println(atomicInteger.get()); </span><br><span class="line">        <span class="comment">// ============== 期望的线程 ================== </span></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">2020</span>, <span class="number">6666</span>)); </span><br><span class="line">        System.out.println(atomicInteger.get()); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="21、原子引用"   >
          <a href="#21、原子引用" class="heading-link"><i class="fas fa-link"></i></a>21、原子引用</h2>
      <blockquote>
<p>解决ABA 问题，引入原子引用！ 对应的思想：乐观锁！</p>
</blockquote>
<p>带版本号 的原子操作！</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference; </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASDemo</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * AtomicStampedReference 注意，</span></span><br><span class="line"><span class="comment">         * 如果泛型是一个包装类，注意对象的引用问题 </span></span><br><span class="line"><span class="comment">         * 正常在业务操作，这里面比较的都是一个个对象 </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 可以有一个初始对应的版本号 1</span></span><br><span class="line">        <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; </span><br><span class="line">                        atomicStampedReference = </span><br><span class="line">                            <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">2020</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// CAS compareAndSet : 比较并交换！ </span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="comment">// 获得版本号</span></span><br><span class="line">                <span class="keyword">int</span> stamp = atomicStampedReference.getStamp(); </span><br><span class="line">                System.out.println(<span class="string">"a1=&gt;"</span>+stamp); </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>); </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace(); </span><br><span class="line">                &#125;</span><br><span class="line">                atomicStampedReference.compareAndSet(</span><br><span class="line">                    <span class="number">2020</span>, </span><br><span class="line">                    <span class="number">2022</span>, </span><br><span class="line">                    atomicStampedReference.getStamp(), <span class="comment">// 最新版本号</span></span><br><span class="line">                    <span class="comment">// 更新版本号</span></span><br><span class="line">                    atomicStampedReference.getStamp() + <span class="number">1</span>); </span><br><span class="line">                      System.out.println(<span class="string">"a2=&gt;"</span></span><br><span class="line">                                 +atomicStampedReference.getStamp()); </span><br><span class="line">                     System.out.println(</span><br><span class="line">                        atomicStampedReference.compareAndSet(</span><br><span class="line">                            <span class="number">2022</span>, </span><br><span class="line">                            <span class="number">2020</span>, </span><br><span class="line">                            atomicStampedReference.getStamp(), </span><br><span class="line">                            atomicStampedReference.getStamp() + <span class="number">1</span>)); </span><br><span class="line">                    System.out.println(<span class="string">"a3=&gt;"</span></span><br><span class="line">                                 +atomicStampedReference.getStamp()); </span><br><span class="line">                &#125;,<span class="string">"a"</span>).start(); </span><br><span class="line">            <span class="comment">// 乐观锁的原理相同！ </span></span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="comment">// 获得版本号 </span></span><br><span class="line">                <span class="keyword">int</span> stamp = atomicStampedReference.getStamp(); </span><br><span class="line">                System.out.println(<span class="string">"b1=&gt;"</span>+stamp); </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>); </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace(); </span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(</span><br><span class="line">                    atomicStampedReference.compareAndSet(</span><br><span class="line">                                    <span class="number">2020</span>, <span class="number">6666</span>, stamp, stamp + <span class="number">1</span>)); </span><br><span class="line">                System.out.println(<span class="string">"b2=&gt;"</span></span><br><span class="line">                +atomicStampedReference.getStamp()); </span><br><span class="line">            &#125;,<span class="string">"b"</span>).start();</span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>结果出现问题</p>
<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/47.png" class="" title="图片">

<p><strong>注意：</strong></p>
<p><strong>Integer 使用了对象缓存机制，默认范围是 -128 ~ 127 ，推荐使用静态工厂方法 valueOf 获取对象实例，而不是 new，因为 valueOf 使用缓存，而 new 一定会创建新的对象分配新的内存空间；</strong></p>
<p>下面是阿里巴巴开发手册的规范点：</p>
<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/48.png" class="" title="图片">




        <h2 id="22、各种锁的理解"   >
          <a href="#22、各种锁的理解" class="heading-link"><i class="fas fa-link"></i></a>22、各种锁的理解</h2>
      
        <h3 id="1、公平锁、非公平锁"   >
          <a href="#1、公平锁、非公平锁" class="heading-link"><i class="fas fa-link"></i></a>1、公平锁、非公平锁</h3>
      <p>公平锁： 非常公平， 不能够插队，必须先来后到！</p>
<p>非公平锁：非常不公平，可以插队 （默认都是非公平）</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="2、可重入锁"   >
          <a href="#2、可重入锁" class="heading-link"><i class="fas fa-link"></i></a>2、可重入锁</h3>
      <p>可重入锁（递归锁）()</p>
<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/49.png" class="" title="图片">


        <h4 id="Synchronized-版"   >
          <a href="#Synchronized-版" class="heading-link"><i class="fas fa-link"></i></a>Synchronized 版</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Synchronized</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sms</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() </span><br><span class="line">                                                           + <span class="string">"sms"</span>);</span><br><span class="line">        call(); <span class="comment">// 这里也有锁(sms锁 里面的call锁)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() </span><br><span class="line">                                                           + <span class="string">"call"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="Lock版"   >
          <a href="#Lock版" class="heading-link"><i class="fas fa-link"></i></a>Lock版</h4>
      <p>// 细节问题：lock.lock(); lock.unlock();<br>        // lock 锁必须配对，否则就会死在里面<br>        // 两个lock() 就需要两次解锁</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone2 phone = <span class="keyword">new</span> Phone2();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone2</span></span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sms</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock(); </span><br><span class="line">        <span class="comment">// 细节问题：lock.lock(); lock.unlock(); </span></span><br><span class="line">        <span class="comment">// lock 锁必须配对，否则就会死在里面</span></span><br><span class="line">        <span class="comment">// 两个lock() 就需要两次解锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() </span><br><span class="line">                                                           + <span class="string">"sms"</span>);</span><br><span class="line">            call(); <span class="comment">// 这里也有锁</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() </span><br><span class="line">                                                           + <span class="string">"call"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="3、自旋锁"   >
          <a href="#3、自旋锁" class="heading-link"><i class="fas fa-link"></i></a>3、自旋锁</h3>
      <p>spinlock</p>
<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/50.png" class="" title="图片">

<p>我们来自定义一个锁测试：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自旋锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinlockDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// int   0</span></span><br><span class="line">    <span class="comment">// Thread  null</span></span><br><span class="line">    <span class="comment">// 原子引用</span></span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = </span><br><span class="line">                                            <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() </span><br><span class="line">                                                       + <span class="string">"==&gt; mylock"</span>);</span><br><span class="line">        <span class="comment">// 自旋锁</span></span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="keyword">null</span>,thread))&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myUnLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()</span><br><span class="line">                                                   + <span class="string">"==&gt; myUnlock"</span>);</span><br><span class="line">        atomicReference.compareAndSet(thread,<span class="keyword">null</span>);<span class="comment">// 解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>测试</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpinLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> </span></span><br><span class="line"><span class="function">                                            InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">//        ReentrantLock reentrantLock = new ReentrantLock();</span></span><br><span class="line"><span class="comment">//        reentrantLock.lock();</span></span><br><span class="line"><span class="comment">//        reentrantLock.unlock();</span></span><br><span class="line">        <span class="comment">// 底层使用的自旋锁CAS</span></span><br><span class="line">        SpinlockDemo lock = <span class="keyword">new</span> SpinlockDemo();<span class="comment">// 定义锁</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">            lock.myLock();<span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.myUnLock();<span class="comment">// 解锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"T1"</span>).start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">            lock.myLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.myUnLock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"T2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/51.png" class="" title="图片">




        <h3 id="4、死锁"   >
          <a href="#4、死锁" class="heading-link"><i class="fas fa-link"></i></a>4、死锁</h3>
      <blockquote>
<p>死锁是什么?</p>
</blockquote>
<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/52.png" class="" title="图片">

<p>一、死锁的四大条件</p>
<ul>
<li><p>互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</p>
</li>
<li><p>请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</p>
</li>
<li><p>不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。</p>
</li>
<li><p>循环等待条件: 若干进程间形成首尾相接循环等待资源的关系</p>
</li>
</ul>
<p><strong>创建死锁</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">deadLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        dead dead = <span class="keyword">new</span> dead(<span class="string">"a"</span>, <span class="string">"b"</span>);</span><br><span class="line">        dead dead1 = <span class="keyword">new</span> dead(<span class="string">"b"</span>, <span class="string">"a"</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(dead).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(dead1).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dead</span> <span class="keyword">implements</span>  <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String a;</span><br><span class="line">    <span class="keyword">private</span> String b;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">dead</span><span class="params">(String a, String b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a=a;</span><br><span class="line">        <span class="keyword">this</span>.b=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (a)&#123;</span><br><span class="line">            System.out.println(a+<span class="string">"==&gt;"</span>+b);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (b)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>第一步 jps -l 找出 问题提的进程</li>
</ul>
<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/53.png" class="" title="图片">

<ul>
<li>第二部 jstack 加线程号</li>
</ul>
<img src="/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/54.png" class="" title="图片">

<p>工作中排查问题：</p>
<ol>
<li>看日志</li>
<li>看堆栈</li>
</ol>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ END ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">Author: </span><span class="copyright-author__value"><a href="https://kingsirz123.github.io">源一</a></span></div><div class="copyright-link"><span class="copyright-link__name">Link: </span><span class="copyright-link__value"><a href="https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">https://kingsirz123.github.io/2021/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">Copyright: </span><span class="copyright-notice__value">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> unless stating additionally</span></div></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2021/03/29/JVM%E5%85%A5%E9%97%A8/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">JVM入门</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2021/03/25/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/"><span class="paginator-prev__text">注解和反射</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">Catalog</span><span class="sidebar-nav-ov">Overview</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、什么是-JUC"><span class="toc-number">1.</span> <span class="toc-text">
          1、什么是 JUC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、线程和进程"><span class="toc-number">2.</span> <span class="toc-text">
          2、线程和进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-真的可以开启线程吗？"><span class="toc-number">2.0.1.</span> <span class="toc-text">
          Java 真的可以开启线程吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#并发、并行"><span class="toc-number">2.0.2.</span> <span class="toc-text">
          并发、并行</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#线程有几个状态"><span class="toc-number">2.0.2.1.</span> <span class="toc-text">
          线程有几个状态</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wait-sleep-区别"><span class="toc-number">2.0.3.</span> <span class="toc-text">
          wait&#x2F;sleep 区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、Synchronized锁"><span class="toc-number">3.</span> <span class="toc-text">
          3、Synchronized锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、Lock锁-重点"><span class="toc-number">4.</span> <span class="toc-text">
          4、Lock锁(重点)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Synchronized-和-Lock-区别："><span class="toc-number">4.0.1.</span> <span class="toc-text">
          Synchronized 和 Lock 区别：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5、生产者和消费者问题"><span class="toc-number">5.</span> <span class="toc-text">
          5、生产者和消费者问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JUC版的生产者和消费者问题"><span class="toc-number">5.0.1.</span> <span class="toc-text">
          JUC版的生产者和消费者问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6、8锁现象"><span class="toc-number">6.</span> <span class="toc-text">
          6、8锁现象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7、集合类不安全"><span class="toc-number">7.</span> <span class="toc-text">
          7、集合类不安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#List-不安全"><span class="toc-number">7.1.</span> <span class="toc-text">
          List 不安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set-不安全"><span class="toc-number">7.2.</span> <span class="toc-text">
          Set 不安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map-不安全"><span class="toc-number">7.3.</span> <span class="toc-text">
          Map 不安全</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8、Callable-简单"><span class="toc-number">8.</span> <span class="toc-text">
          8、Callable (简单)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9、常用的辅助类-必会"><span class="toc-number">9.</span> <span class="toc-text">
          9、常用的辅助类(必会)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1、CountDownLatch"><span class="toc-number">9.1.</span> <span class="toc-text">
          9.1、CountDownLatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2、CyclicBarrier"><span class="toc-number">9.2.</span> <span class="toc-text">
          9.2、CyclicBarrier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3、Semaphore"><span class="toc-number">9.3.</span> <span class="toc-text">
          9.3、Semaphore</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10、读写锁-ReadWriteLock"><span class="toc-number">10.</span> <span class="toc-text">
          10、读写锁 ReadWriteLock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11、阻塞队列"><span class="toc-number">11.</span> <span class="toc-text">
          11、阻塞队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BlockingQueue"><span class="toc-number">11.0.1.</span> <span class="toc-text">
          BlockingQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SynchronousQueue"><span class="toc-number">11.0.2.</span> <span class="toc-text">
          SynchronousQueue</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12、线程池-重点"><span class="toc-number">12.</span> <span class="toc-text">
          12、线程池(重点)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#线程池：3大方法"><span class="toc-number">12.0.1.</span> <span class="toc-text">
          线程池：3大方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程池：7大参数"><span class="toc-number">12.0.2.</span> <span class="toc-text">
          线程池：7大参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程池：4种拒绝策略"><span class="toc-number">12.0.3.</span> <span class="toc-text">
          线程池：4种拒绝策略</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13、四大函数式接口（必需掌握）"><span class="toc-number">13.</span> <span class="toc-text">
          13、四大函数式接口（必需掌握）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Function-函数式接口"><span class="toc-number">13.0.1.</span> <span class="toc-text">
          Function 函数式接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Predicate-断定型接口"><span class="toc-number">13.0.2.</span> <span class="toc-text">
          Predicate 断定型接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Consumer-消费型接口"><span class="toc-number">13.0.3.</span> <span class="toc-text">
          Consumer 消费型接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Supplier-供给型接口"><span class="toc-number">13.0.4.</span> <span class="toc-text">
          Supplier 供给型接口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14、Stream-流式计算"><span class="toc-number">14.</span> <span class="toc-text">
          14、Stream 流式计算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15、ForkJoin"><span class="toc-number">15.</span> <span class="toc-text">
          15、ForkJoin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16、异步回调"><span class="toc-number">16.</span> <span class="toc-text">
          16、异步回调</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17、JMM"><span class="toc-number">17.</span> <span class="toc-text">
          17、JMM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18、Volatile"><span class="toc-number">18.</span> <span class="toc-text">
          18、Volatile</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、保证可见性"><span class="toc-number">18.0.1.</span> <span class="toc-text">
          1、保证可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不保证原子性"><span class="toc-number">18.0.2.</span> <span class="toc-text">
          不保证原子性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#指令重排"><span class="toc-number">18.0.3.</span> <span class="toc-text">
          指令重排</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19、彻底玩转单例模式"><span class="toc-number">19.</span> <span class="toc-text">
          19、彻底玩转单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#饿汉式"><span class="toc-number">19.0.1.</span> <span class="toc-text">
          饿汉式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#懒汉式"><span class="toc-number">19.0.2.</span> <span class="toc-text">
          懒汉式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#懒汉式-单线程版本"><span class="toc-number">19.0.2.1.</span> <span class="toc-text">
          懒汉式-单线程版本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#懒汉式-多线程-低性能版"><span class="toc-number">19.0.2.2.</span> <span class="toc-text">
          懒汉式-多线程-低性能版</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DCL懒汉式-双重检测锁模式"><span class="toc-number">19.0.2.3.</span> <span class="toc-text">
          DCL懒汉式(双重检测锁模式)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#增加volatile"><span class="toc-number">19.0.2.4.</span> <span class="toc-text">
          增加volatile</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#登记式-静态内部类"><span class="toc-number">19.0.3.</span> <span class="toc-text">
          登记式&#x2F;静态内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#反射破坏单例"><span class="toc-number">19.0.4.</span> <span class="toc-text">
          反射破坏单例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#枚举式"><span class="toc-number">20.</span> <span class="toc-text">
          枚举式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20、深入理解CAS"><span class="toc-number">21.</span> <span class="toc-text">
          20、深入理解CAS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21、原子引用"><span class="toc-number">22.</span> <span class="toc-text">
          21、原子引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22、各种锁的理解"><span class="toc-number">23.</span> <span class="toc-text">
          22、各种锁的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、公平锁、非公平锁"><span class="toc-number">23.1.</span> <span class="toc-text">
          1、公平锁、非公平锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、可重入锁"><span class="toc-number">23.2.</span> <span class="toc-text">
          2、可重入锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Synchronized-版"><span class="toc-number">23.2.1.</span> <span class="toc-text">
          Synchronized 版</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lock版"><span class="toc-number">23.2.2.</span> <span class="toc-text">
          Lock版</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、自旋锁"><span class="toc-number">23.3.</span> <span class="toc-text">
          3、自旋锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、死锁"><span class="toc-number">23.4.</span> <span class="toc-text">
          4、死锁</span></a></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/3.jpeg" alt="avatar"></div><p class="sidebar-ov-author__text">一生中你唯一需要回头的时候，是为了看自己到底走了多远。</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/KingSirZ123/" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://plus.google.com/" target="_blank" rel="noopener" data-popover="Google" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-google"></i></span></a><a class="sidebar-ov-social-item" href="https://twitter.com/" target="_blank" rel="noopener" data-popover="Twitter" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-twitter"></i></span></a><a class="sidebar-ov-social-item" href="https://youtube.com/" target="_blank" rel="noopener" data-popover="Youtube" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-youtube"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">46</div><div class="sidebar-ov-state-item__name">Archives</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">0</div><div class="sidebar-ov-state-item__name">Categories</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">0</div><div class="sidebar-ov-state-item__name">Tags</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="Creative Commons" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">You have read </span><span class="sidebar-reading-info__num">0</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020.7.19~2021</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>你好世界</span></div><div><span>Theme - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.1.1</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.1.1"></script><script src="/js/stun-boot.js?v=2.1.1"></script><script src="/js/scroll.js?v=2.1.1"></script><script src="/js/header.js?v=2.1.1"></script><script src="/js/sidebar.js?v=2.1.1"></script></body></html>